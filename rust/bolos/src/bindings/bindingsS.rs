/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const BOLOS_VERSION: &'static [u8; 6usize] = b"1.6.1\0";
pub const IO_SEPROXYHAL_BUFFER_SIZE_B: u32 = 128;
pub const IO_USB_MAX_ENDPOINTS: u32 = 7;
pub const IO_HID_EP_LENGTH: u32 = 64;
pub const USB_SEGMENT_SIZE: u32 = 64;
pub const WEBUSB_URL_SIZE_B: u32 = 0;
pub const WEBUSB_URL: &'static [u8; 1usize] = b"\0";
pub const BAGL_NOFILL: u32 = 0;
pub const BAGL_FILL: u32 = 1;
pub const BAGL_OUTLINE: u32 = 2;
pub const BAGL_NOICON: u32 = 3;
pub const BAGL_FILL_CIRCLE_1_OCTANT: u32 = 1;
pub const BAGL_FILL_CIRCLE_2_OCTANT: u32 = 2;
pub const BAGL_FILL_CIRCLE_3_OCTANT: u32 = 4;
pub const BAGL_FILL_CIRCLE_4_OCTANT: u32 = 8;
pub const BAGL_FILL_CIRCLE_5_OCTANT: u32 = 16;
pub const BAGL_FILL_CIRCLE_6_OCTANT: u32 = 32;
pub const BAGL_FILL_CIRCLE_7_OCTANT: u32 = 64;
pub const BAGL_FILL_CIRCLE_8_OCTANT: u32 = 128;
pub const BAGL_FILL_CIRCLE: u32 = 255;
pub const BAGL_FILL_CIRCLE_3PI2_2PI: u32 = 3;
pub const BAGL_FILL_CIRCLE_PI_3PI2: u32 = 12;
pub const BAGL_FILL_CIRCLE_0_PI2: u32 = 48;
pub const BAGL_FILL_CIRCLE_PI2_PI: u32 = 192;
pub const BAGL_TYPE_FLAGS_MASK: u32 = 128;
pub const BAGL_FONT_ID_MASK: u32 = 4095;
pub const BAGL_FONT_ALIGNMENT_HORIZONTAL_MASK: u32 = 49152;
pub const BAGL_FONT_ALIGNMENT_LEFT: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_RIGHT: u32 = 16384;
pub const BAGL_FONT_ALIGNMENT_CENTER: u32 = 32768;
pub const BAGL_FONT_ALIGNMENT_VERTICAL_MASK: u32 = 12288;
pub const BAGL_FONT_ALIGNMENT_TOP: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_BOTTOM: u32 = 4096;
pub const BAGL_FONT_ALIGNMENT_MIDDLE: u32 = 8192;
pub const BAGL_STROKE_FLAG_ONESHOT: u32 = 128;
pub const BAGL_ENCODING_LATIN1: u32 = 0;
pub const BAGL_FONT_SYMBOLS_0_CLEAR: [u8; 2usize] = [128u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DOT: [u8; 2usize] = [129u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LEFT: [u8; 2usize] = [130u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LIGHTNING: [u8; 2usize] = [131u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_MINIRIGHT: [u8; 2usize] = [132u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DASHBOARD: [u8; 2usize] = [133u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_SETTINGS: [u8; 2usize] = [134u8, 0u8];
pub const BAGL_FONT_SYMBOLS_1_CARET: [u8; 2usize] = [160u8, 0u8];
pub const TARGET_ID: u32 = 823132164;
pub const __SC000_REV: u32 = 1;
pub const __SC300_REV: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 2;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const NVM_ERASED_WORD_VALUE: u32 = 4294967295;
pub const __SC000_CMSIS_VERSION_MAIN: u32 = 3;
pub const __SC000_CMSIS_VERSION_SUB: u32 = 1;
pub const __SC000_CMSIS_VERSION: u32 = 196609;
pub const __CORTEX_SC: u32 = 0;
pub const __FPU_USED: u32 = 0;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 7;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967168;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SCB_SFCR_UNIBRTIMING_Pos: u32 = 0;
pub const SCB_SFCR_UNIBRTIMING_Msk: u32 = 32768;
pub const SCB_SFCR_SECKEY_Pos: u32 = 16;
pub const SCB_SFCR_SECKEY_Msk: u32 = 2147450880;
pub const SCnSCB_ACTLR_DISMCYCINT_Pos: u32 = 0;
pub const SCnSCB_ACTLR_DISMCYCINT_Msk: u32 = 1;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const SCS_BASE: u32 = 3758153728;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const CX_APILEVEL: u32 = 10;
pub const CX_COMPAT_APILEVEL: u32 = 10;
pub const APPLICATION_FLAG_NONE: u32 = 0;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_IO: u32 = 8192;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const CXPORT_ED_DES: u32 = 1;
pub const CXPORT_ED_AES: u32 = 2;
pub const CXPORT_ED_RSA: u32 = 4;
pub const IMPL_IO_APDU_BUFFER_SIZE: u32 = 260;
pub const IO_APDU_BUFFER_SIZE: u32 = 260;
pub const CUSTOMCA_MAXLEN: u32 = 64;
pub const CHANNEL_APDU: u32 = 0;
pub const CHANNEL_KEYBOARD: u32 = 1;
pub const CHANNEL_SPI: u32 = 2;
pub const IO_RESET_AFTER_REPLIED: u32 = 128;
pub const IO_RECEIVE_DATA: u32 = 64;
pub const IO_RETURN_AFTER_TX: u32 = 32;
pub const IO_ASYNCH_REPLY: u32 = 16;
pub const IO_FINISHED: u32 = 8;
pub const IO_FLAGS: u32 = 248;
pub const BLE_SEGMENT_SIZE: u32 = 64;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_OVERFLOW: u32 = 3;
pub const EXCEPTION_SECURITY: u32 = 4;
pub const INVALID_CRC: u32 = 5;
pub const INVALID_CHECKSUM: u32 = 6;
pub const INVALID_COUNTER: u32 = 7;
pub const NOT_SUPPORTED: u32 = 8;
pub const INVALID_STATE: u32 = 9;
pub const TIMEOUT: u32 = 10;
pub const EXCEPTION_PIC: u32 = 11;
pub const EXCEPTION_APPEXIT: u32 = 12;
pub const EXCEPTION_IO_OVERFLOW: u32 = 13;
pub const EXCEPTION_IO_HEADER: u32 = 14;
pub const EXCEPTION_IO_STATE: u32 = 15;
pub const EXCEPTION_IO_RESET: u32 = 16;
pub const EXCEPTION_CXPORT: u32 = 17;
pub const EXCEPTION_SYSTEM: u32 = 18;
pub const NOT_ENOUGH_SPACE: u32 = 19;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_RIPEMD160_SIZE: u32 = 20;
pub const CX_SHA224_SIZE: u32 = 28;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const ROWS: u32 = 8;
pub const COLS1024: u32 = 16;
pub const SIZE1024: u32 = 128;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const CX_CRC16_INIT: u32 = 65535;
pub const BOLOS_UX_OK: u32 = 170;
pub const BOLOS_UX_CANCEL: u32 = 85;
pub const BOLOS_UX_ERROR: u32 = 214;
pub const BOLOS_UX_IGNORE: u32 = 151;
pub const BOLOS_UX_REDRAW: u32 = 105;
pub const BOLOS_UX_CONTINUE: u32 = 0;
pub const BOLOS_TAG_APPNAME: u32 = 1;
pub const BOLOS_TAG_APPVERSION: u32 = 2;
pub const BOLOS_TAG_ICON: u32 = 3;
pub const BOLOS_TAG_DERIVEPATH: u32 = 4;
pub const BOLOS_TAG_DATA_SIZE: u32 = 5;
pub const BOLOS_TAG_DEPENDENCY: u32 = 6;
pub const BOLOS_TAG_USER_TAG: u32 = 32;
pub const BOLOS_UX_MODE_UPPERCASE: u32 = 0;
pub const BOLOS_UX_MODE_LOWERCASE: u32 = 1;
pub const BOLOS_UX_MODE_SYMBOLS: u32 = 2;
pub const BOLOS_UX_MODE_COUNT: u32 = 3;
pub const BOLOS_UX_KEYBOARD_TEXT_BUFFER_SIZE: u32 = 32;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_BIP39: u32 = 1;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_ELECTRUM: u32 = 2;
pub const HDW_NORMAL: u32 = 0;
pub const HDW_ED25519_SLIP10: u32 = 1;
pub const HDW_SLIP21: u32 = 2;
pub const DEFAULT_PIN_RETRIES: u32 = 3;
pub const OS_FLAG_RECOVERY: u32 = 1;
pub const OS_FLAG_SIGNED_MCU_CODE: u32 = 2;
pub const OS_FLAG_ONBOARDED: u32 = 4;
pub const OS_FLAG_PIN_VALIDATED: u32 = 128;
pub const BOLOS_APPNAME_MAX_SIZE_B: u32 = 32;
pub const OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const BOLOS_SECURITY_BOOT_DELAY_H: i32 = -358499;
pub const BOLOS_SECURITY_ONBOARD_DELAY_S: u32 = 5;
pub const BOLOS_SECURITY_ATTESTATION_DELAY_S: u32 = 5;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const SYSCALL_check_api_level_ID_IN: u32 = 1610613047;
pub const SYSCALL_check_api_level_ID_OUT: u32 = 2415919558;
pub const SYSCALL_halt_ID_IN: u32 = 1610613308;
pub const SYSCALL_halt_ID_OUT: u32 = 2415919629;
pub const SYSCALL_nvm_write_ID_IN: u32 = 1610613631;
pub const SYSCALL_nvm_write_ID_OUT: u32 = 2415920060;
pub const SYSCALL_cx_rng_u8_ID_IN: u32 = 1610613952;
pub const SYSCALL_cx_rng_u8_ID_OUT: u32 = 2415920165;
pub const SYSCALL_cx_rng_ID_IN: u32 = 1610614060;
pub const SYSCALL_cx_rng_ID_OUT: u32 = 2415920487;
pub const SYSCALL_cx_hash_ID_IN: u32 = 1610614587;
pub const SYSCALL_cx_hash_ID_OUT: u32 = 2415921069;
pub const SYSCALL_cx_ripemd160_init_ID_IN: u32 = 1610614911;
pub const SYSCALL_cx_ripemd160_init_ID_OUT: u32 = 2415921400;
pub const SYSCALL_cx_sha224_init_ID_IN: u32 = 1610615131;
pub const SYSCALL_cx_sha224_init_ID_OUT: u32 = 2415921437;
pub const SYSCALL_cx_sha256_init_ID_IN: u32 = 1610615515;
pub const SYSCALL_cx_sha256_init_ID_OUT: u32 = 2415921764;
pub const SYSCALL_cx_hash_sha256_ID_IN: u32 = 1610615596;
pub const SYSCALL_cx_hash_sha256_ID_OUT: u32 = 2415922080;
pub const SYSCALL_cx_sha384_init_ID_IN: u32 = 1610615851;
pub const SYSCALL_cx_sha384_init_ID_OUT: u32 = 2415922351;
pub const SYSCALL_cx_sha512_init_ID_IN: u32 = 1610616257;
pub const SYSCALL_cx_sha512_init_ID_OUT: u32 = 2415922670;
pub const SYSCALL_cx_hash_sha512_ID_IN: u32 = 1610616392;
pub const SYSCALL_cx_hash_sha512_ID_OUT: u32 = 2415922773;
pub const SYSCALL_cx_sha3_init_ID_IN: u32 = 1610616785;
pub const SYSCALL_cx_sha3_init_ID_OUT: u32 = 2415923062;
pub const SYSCALL_cx_keccak_init_ID_IN: u32 = 1610617039;
pub const SYSCALL_cx_keccak_init_ID_OUT: u32 = 2415923416;
pub const SYSCALL_cx_shake128_init_ID_IN: u32 = 1610650377;
pub const SYSCALL_cx_shake128_init_ID_OUT: u32 = 2415956881;
pub const SYSCALL_cx_shake256_init_ID_IN: u32 = 1610650854;
pub const SYSCALL_cx_shake256_init_ID_OUT: u32 = 2415957159;
pub const SYSCALL_cx_sha3_xof_init_ID_IN: u32 = 1610617152;
pub const SYSCALL_cx_sha3_xof_init_ID_OUT: u32 = 2415923680;
pub const SYSCALL_cx_blake2b_init_ID_IN: u32 = 1610617608;
pub const SYSCALL_cx_blake2b_init_ID_OUT: u32 = 2415924121;
pub const SYSCALL_cx_blake2b_init2_ID_IN: u32 = 1610617958;
pub const SYSCALL_cx_blake2b_init2_ID_OUT: u32 = 2415924369;
pub const SYSCALL_cx_groestl_init_ID_IN: u32 = 1610617376;
pub const SYSCALL_cx_groestl_init_ID_OUT: u32 = 2415923779;
pub const SYSCALL_cx_hmac_ripemd160_init_ID_IN: u32 = 1610618319;
pub const SYSCALL_cx_hmac_ripemd160_init_ID_OUT: u32 = 2415924598;
pub const SYSCALL_cx_hmac_sha256_init_ID_IN: u32 = 1610618577;
pub const SYSCALL_cx_hmac_sha256_init_ID_OUT: u32 = 2415924743;
pub const SYSCALL_cx_hmac_sha512_init_ID_IN: u32 = 1610618803;
pub const SYSCALL_cx_hmac_sha512_init_ID_OUT: u32 = 2415925017;
pub const SYSCALL_cx_hmac_ID_IN: u32 = 1610619089;
pub const SYSCALL_cx_hmac_ID_OUT: u32 = 2415925462;
pub const SYSCALL_cx_hmac_sha512_ID_IN: u32 = 1610619343;
pub const SYSCALL_cx_hmac_sha512_ID_OUT: u32 = 2415925630;
pub const SYSCALL_cx_hmac_sha256_ID_IN: u32 = 1610619435;
pub const SYSCALL_cx_hmac_sha256_ID_OUT: u32 = 2415925940;
pub const SYSCALL_cx_pbkdf2_ID_IN: u32 = 1610654252;
pub const SYSCALL_cx_pbkdf2_ID_OUT: u32 = 2415960661;
pub const SYSCALL_cx_des_init_key_ID_IN: u32 = 1610620035;
pub const SYSCALL_cx_des_init_key_ID_OUT: u32 = 2415926349;
pub const SYSCALL_cx_des_iv_ID_IN: u32 = 1610654498;
pub const SYSCALL_cx_des_iv_ID_OUT: u32 = 2415960903;
pub const SYSCALL_cx_des_ID_IN: u32 = 1610620494;
pub const SYSCALL_cx_des_ID_OUT: u32 = 2415927038;
pub const SYSCALL_cx_aes_init_key_ID_IN: u32 = 1610620715;
pub const SYSCALL_cx_aes_init_key_ID_OUT: u32 = 2415927089;
pub const SYSCALL_cx_aes_iv_ID_IN: u32 = 1610654885;
pub const SYSCALL_cx_aes_iv_ID_OUT: u32 = 2415961314;
pub const SYSCALL_cx_aes_ID_IN: u32 = 1610621410;
pub const SYSCALL_cx_aes_ID_OUT: u32 = 2415927612;
pub const SYSCALL_cx_rsa_init_public_key_ID_IN: u32 = 1610621669;
pub const SYSCALL_cx_rsa_init_public_key_ID_OUT: u32 = 2415927947;
pub const SYSCALL_cx_rsa_init_private_key_ID_IN: u32 = 1610621751;
pub const SYSCALL_cx_rsa_init_private_key_ID_OUT: u32 = 2415928259;
pub const SYSCALL_cx_rsa_generate_pair_ID_IN: u32 = 1610622113;
pub const SYSCALL_cx_rsa_generate_pair_ID_OUT: u32 = 2415928573;
pub const SYSCALL_cx_rsa_sign_ID_IN: u32 = 1610622406;
pub const SYSCALL_cx_rsa_sign_ID_OUT: u32 = 2415928819;
pub const SYSCALL_cx_rsa_verify_ID_IN: u32 = 1610622635;
pub const SYSCALL_cx_rsa_verify_ID_OUT: u32 = 2415929011;
pub const SYSCALL_cx_rsa_encrypt_ID_IN: u32 = 1610622938;
pub const SYSCALL_cx_rsa_encrypt_ID_OUT: u32 = 2415929289;
pub const SYSCALL_cx_rsa_decrypt_ID_IN: u32 = 1610623108;
pub const SYSCALL_cx_rsa_decrypt_ID_OUT: u32 = 2415929511;
pub const SYSCALL_cx_ecfp_is_valid_point_ID_IN: u32 = 1610623339;
pub const SYSCALL_cx_ecfp_is_valid_point_ID_OUT: u32 = 2415929601;
pub const SYSCALL_cx_ecfp_is_cryptographic_point_ID_IN: u32 = 1610623715;
pub const SYSCALL_cx_ecfp_is_cryptographic_point_ID_OUT: u32 = 2415930096;
pub const SYSCALL_cx_ecfp_add_point_ID_IN: u32 = 1610623767;
pub const SYSCALL_cx_ecfp_add_point_ID_OUT: u32 = 2415930311;
pub const SYSCALL_cx_ecfp_scalar_mult_ID_IN: u32 = 1610624243;
pub const SYSCALL_cx_ecfp_scalar_mult_ID_OUT: u32 = 2415930595;
pub const SYSCALL_cx_ecfp_init_public_key_ID_IN: u32 = 1610624493;
pub const SYSCALL_cx_ecfp_init_public_key_ID_OUT: u32 = 2415930697;
pub const SYSCALL_cx_ecfp_init_private_key_ID_IN: u32 = 1610624746;
pub const SYSCALL_cx_ecfp_init_private_key_ID_OUT: u32 = 2415930979;
pub const SYSCALL_cx_ecfp_generate_pair_ID_IN: u32 = 1610624814;
pub const SYSCALL_cx_ecfp_generate_pair_ID_OUT: u32 = 2415931252;
pub const SYSCALL_cx_ecfp_generate_pair2_ID_IN: u32 = 1610625055;
pub const SYSCALL_cx_ecfp_generate_pair2_ID_OUT: u32 = 2415931622;
pub const SYSCALL_cx_ecdsa_sign_ID_IN: u32 = 1610627315;
pub const SYSCALL_cx_ecdsa_sign_ID_OUT: u32 = 2415933558;
pub const SYSCALL_cx_ecdsa_verify_ID_IN: u32 = 1610627569;
pub const SYSCALL_cx_ecdsa_verify_ID_OUT: u32 = 2415933927;
pub const SYSCALL_cx_edward_compress_point_ID_IN: u32 = 1610625881;
pub const SYSCALL_cx_edward_compress_point_ID_OUT: u32 = 2415932203;
pub const SYSCALL_cx_edward_decompress_point_ID_IN: u32 = 1610626097;
pub const SYSCALL_cx_edward_decompress_point_ID_OUT: u32 = 2415932618;
pub const SYSCALL_cx_eddsa_get_public_key_ID_IN: u32 = 1610626332;
pub const SYSCALL_cx_eddsa_get_public_key_ID_OUT: u32 = 2415932863;
pub const SYSCALL_cx_eddsa_sign_ID_IN: u32 = 1610626619;
pub const SYSCALL_cx_eddsa_sign_ID_OUT: u32 = 2415933174;
pub const SYSCALL_cx_eddsa_verify_ID_IN: u32 = 1610627018;
pub const SYSCALL_cx_eddsa_verify_ID_OUT: u32 = 2415933217;
pub const SYSCALL_cx_ecschnorr_sign_ID_IN: u32 = 1610625345;
pub const SYSCALL_cx_ecschnorr_sign_ID_OUT: u32 = 2415931722;
pub const SYSCALL_cx_ecschnorr_verify_ID_IN: u32 = 1610625541;
pub const SYSCALL_cx_ecschnorr_verify_ID_OUT: u32 = 2415932151;
pub const SYSCALL_cx_ecdh_ID_IN: u32 = 1610627741;
pub const SYSCALL_cx_ecdh_ID_OUT: u32 = 2415934100;
pub const SYSCALL_cx_crc16_ID_IN: u32 = 1610650104;
pub const SYSCALL_cx_crc16_ID_OUT: u32 = 2415956268;
pub const SYSCALL_cx_crc16_update_ID_IN: u32 = 1610650222;
pub const SYSCALL_cx_crc16_update_ID_OUT: u32 = 2415956715;
pub const SYSCALL_cx_math_cmp_ID_IN: u32 = 1610628443;
pub const SYSCALL_cx_math_cmp_ID_OUT: u32 = 2415934908;
pub const SYSCALL_cx_math_is_zero_ID_IN: u32 = 1610628663;
pub const SYSCALL_cx_math_is_zero_ID_OUT: u32 = 2415935056;
pub const SYSCALL_cx_math_add_ID_IN: u32 = 1610629115;
pub const SYSCALL_cx_math_add_ID_OUT: u32 = 2415935448;
pub const SYSCALL_cx_math_sub_ID_IN: u32 = 1610629279;
pub const SYSCALL_cx_math_sub_ID_OUT: u32 = 2415935517;
pub const SYSCALL_cx_math_mult_ID_IN: u32 = 1610629438;
pub const SYSCALL_cx_math_mult_ID_OUT: u32 = 2415935938;
pub const SYSCALL_cx_math_addm_ID_IN: u32 = 1610629798;
pub const SYSCALL_cx_math_addm_ID_OUT: u32 = 2415936072;
pub const SYSCALL_cx_math_subm_ID_IN: u32 = 1610630013;
pub const SYSCALL_cx_math_subm_ID_OUT: u32 = 2415936480;
pub const SYSCALL_cx_math_multm_ID_IN: u32 = 1610630213;
pub const SYSCALL_cx_math_multm_ID_OUT: u32 = 2415936755;
pub const SYSCALL_cx_math_powm_ID_IN: u32 = 1610630477;
pub const SYSCALL_cx_math_powm_ID_OUT: u32 = 2415936830;
pub const SYSCALL_cx_math_modm_ID_IN: u32 = 1610630725;
pub const SYSCALL_cx_math_modm_ID_OUT: u32 = 2415937164;
pub const SYSCALL_cx_math_invprimem_ID_IN: u32 = 1610631145;
pub const SYSCALL_cx_math_invprimem_ID_OUT: u32 = 2415937305;
pub const SYSCALL_cx_math_invintm_ID_IN: u32 = 1610631212;
pub const SYSCALL_cx_math_invintm_ID_OUT: u32 = 2415937681;
pub const SYSCALL_cx_math_is_prime_ID_IN: u32 = 1610631496;
pub const SYSCALL_cx_math_is_prime_ID_OUT: u32 = 2415938042;
pub const SYSCALL_cx_math_next_prime_ID_IN: u32 = 1610631844;
pub const SYSCALL_cx_math_next_prime_ID_OUT: u32 = 2415938251;
pub const SYSCALL_os_perso_erase_all_ID_IN: u32 = 1610632181;
pub const SYSCALL_os_perso_erase_all_ID_OUT: u32 = 2415938548;
pub const SYSCALL_os_perso_set_pin_ID_IN: u32 = 1610632415;
pub const SYSCALL_os_perso_set_pin_ID_OUT: u32 = 2415938709;
pub const SYSCALL_os_perso_set_current_identity_pin_ID_IN: u32 = 1610632702;
pub const SYSCALL_os_perso_set_current_identity_pin_ID_OUT: u32 = 2415938826;
pub const SYSCALL_os_perso_set_seed_ID_IN: u32 = 1610632892;
pub const SYSCALL_os_perso_set_seed_ID_OUT: u32 = 2415939306;
pub const SYSCALL_os_perso_derive_and_set_seed_ID_IN: u32 = 1610633149;
pub const SYSCALL_os_perso_derive_and_set_seed_ID_OUT: u32 = 2415939535;
pub const SYSCALL_os_perso_set_words_ID_IN: u32 = 1610633240;
pub const SYSCALL_os_perso_set_words_ID_OUT: u32 = 2415939818;
pub const SYSCALL_os_perso_finalize_ID_IN: u32 = 1610633600;
pub const SYSCALL_os_perso_finalize_ID_OUT: u32 = 2415939924;
pub const SYSCALL_os_perso_isonboarded_ID_IN: u32 = 1610653519;
pub const SYSCALL_os_perso_isonboarded_ID_OUT: u32 = 2415959826;
pub const SYSCALL_os_perso_derive_node_bip32_ID_IN: u32 = 1610634170;
pub const SYSCALL_os_perso_derive_node_bip32_ID_OUT: u32 = 2415940382;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID_IN: u32 = 1610655448;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID_OUT: u32 = 2415961604;
pub const SYSCALL_os_perso_seed_cookie_ID_IN: u32 = 1610655996;
pub const SYSCALL_os_perso_seed_cookie_ID_OUT: u32 = 2415962231;
pub const SYSCALL_os_endorsement_get_code_hash_ID_IN: u32 = 1610634511;
pub const SYSCALL_os_endorsement_get_code_hash_ID_OUT: u32 = 2415941025;
pub const SYSCALL_os_endorsement_get_public_key_ID_IN: u32 = 1610634995;
pub const SYSCALL_os_endorsement_get_public_key_ID_OUT: u32 = 2415941273;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID_IN: u32 = 1610635084;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID_OUT: u32 = 2415941503;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID_IN: u32 = 1610635356;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID_OUT: u32 = 2415941728;
pub const SYSCALL_os_endorsement_key1_sign_data_ID_IN: u32 = 1610635736;
pub const SYSCALL_os_endorsement_key1_sign_data_ID_OUT: u32 = 2415941931;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID_IN: u32 = 1610635850;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID_OUT: u32 = 2415942206;
pub const SYSCALL_os_global_pin_is_validated_ID_IN: u32 = 1610653756;
pub const SYSCALL_os_global_pin_is_validated_ID_OUT: u32 = 2415960184;
pub const SYSCALL_os_global_pin_check_ID_IN: u32 = 1610653954;
pub const SYSCALL_os_global_pin_check_ID_OUT: u32 = 2415960531;
pub const SYSCALL_os_global_pin_invalidate_ID_IN: u32 = 1610636752;
pub const SYSCALL_os_global_pin_invalidate_ID_OUT: u32 = 2415943163;
pub const SYSCALL_os_global_pin_retries_ID_IN: u32 = 1610636889;
pub const SYSCALL_os_global_pin_retries_ID_OUT: u32 = 2415943192;
pub const SYSCALL_os_registry_count_ID_IN: u32 = 1610637120;
pub const SYSCALL_os_registry_count_ID_OUT: u32 = 2415943430;
pub const SYSCALL_os_registry_get_ID_IN: u32 = 1610637413;
pub const SYSCALL_os_registry_get_ID_OUT: u32 = 2415943858;
pub const SYSCALL_os_ux_ID_IN: u32 = 1610638424;
pub const SYSCALL_os_ux_ID_OUT: u32 = 2415944735;
pub const SYSCALL_os_ux_result_ID_IN: u32 = 1610638592;
pub const SYSCALL_os_ux_result_ID_OUT: u32 = 2415945136;
pub const SYSCALL_os_ux_read_parameters_ID_IN: u32 = 1610639015;
pub const SYSCALL_os_ux_read_parameters_ID_OUT: u32 = 2415945387;
pub const SYSCALL_os_lib_call_ID_IN: u32 = 1610639117;
pub const SYSCALL_os_lib_call_ID_OUT: u32 = 2415945564;
pub const SYSCALL_os_lib_end_ID_IN: u32 = 1610639501;
pub const SYSCALL_os_lib_end_ID_OUT: u32 = 2415945736;
pub const SYSCALL_os_lib_throw_ID_IN: u32 = 1610639685;
pub const SYSCALL_os_lib_throw_ID_OUT: u32 = 2415946119;
pub const SYSCALL_os_flags_ID_IN: u32 = 1610639982;
pub const SYSCALL_os_flags_ID_OUT: u32 = 2415946367;
pub const SYSCALL_os_version_ID_IN: u32 = 1610640312;
pub const SYSCALL_os_version_ID_OUT: u32 = 2415946692;
pub const SYSCALL_os_serial_ID_IN: u32 = 1610640563;
pub const SYSCALL_os_serial_ID_OUT: u32 = 2415946966;
pub const SYSCALL_os_seph_features_ID_IN: u32 = 1610641110;
pub const SYSCALL_os_seph_features_ID_OUT: u32 = 2415947332;
pub const SYSCALL_os_seph_version_ID_IN: u32 = 1610641324;
pub const SYSCALL_os_seph_version_ID_OUT: u32 = 2415947613;
pub const SYSCALL_os_bootloader_version_ID_IN: u32 = 1610656023;
pub const SYSCALL_os_bootloader_version_ID_OUT: u32 = 2415962490;
pub const SYSCALL_os_setting_get_ID_IN: u32 = 1610641605;
pub const SYSCALL_os_setting_get_ID_OUT: u32 = 2415947951;
pub const SYSCALL_os_setting_set_ID_IN: u32 = 1610641814;
pub const SYSCALL_os_setting_set_ID_OUT: u32 = 2415948197;
pub const SYSCALL_os_get_memory_info_ID_IN: u32 = 1610642019;
pub const SYSCALL_os_get_memory_info_ID_OUT: u32 = 2415948491;
pub const SYSCALL_os_registry_get_tag_ID_IN: u32 = 1610642257;
pub const SYSCALL_os_registry_get_tag_ID_OUT: u32 = 2415948681;
pub const SYSCALL_os_registry_get_current_app_tag_ID_IN: u32 = 1610642644;
pub const SYSCALL_os_registry_get_current_app_tag_ID_OUT: u32 = 2415948935;
pub const SYSCALL_os_customca_verify_ID_IN: u32 = 1610649697;
pub const SYSCALL_os_customca_verify_ID_OUT: u32 = 2415956098;
pub const SYSCALL_os_sched_exec_ID_IN: u32 = 1610652025;
pub const SYSCALL_os_sched_exec_ID_OUT: u32 = 2415958344;
pub const SYSCALL_os_sched_exit_ID_IN: u32 = 1610652350;
pub const SYSCALL_os_sched_exit_ID_OUT: u32 = 2415958750;
pub const SYSCALL_os_sched_is_running_ID_IN: u32 = 1610652634;
pub const SYSCALL_os_sched_is_running_ID_OUT: u32 = 2415958909;
pub const SYSCALL_os_sched_create_ID_IN: u32 = 1610643399;
pub const SYSCALL_os_sched_create_ID_OUT: u32 = 2415949734;
pub const SYSCALL_os_sched_kill_ID_IN: u32 = 1610643672;
pub const SYSCALL_os_sched_kill_ID_OUT: u32 = 2415949885;
pub const SYSCALL_io_seph_send_ID_IN: u32 = 1610646401;
pub const SYSCALL_io_seph_send_ID_OUT: u32 = 2415952877;
pub const SYSCALL_io_seph_is_status_sent_ID_IN: u32 = 1610646715;
pub const SYSCALL_io_seph_is_status_sent_ID_OUT: u32 = 2415952901;
pub const SYSCALL_io_seph_recv_ID_IN: u32 = 1610647012;
pub const SYSCALL_io_seph_recv_ID_OUT: u32 = 2415953399;
pub const SYSCALL_nvm_write_page_ID_IN: u32 = 1610647294;
pub const SYSCALL_nvm_write_page_ID_OUT: u32 = 2415953660;
pub const SYSCALL_try_context_get_ID_IN: u32 = 1610647473;
pub const SYSCALL_try_context_get_ID_OUT: u32 = 2415953698;
pub const SYSCALL_try_context_set_ID_IN: u32 = 1610647669;
pub const SYSCALL_try_context_set_ID_OUT: u32 = 2415953980;
pub const SYSCALL_cx_rng_u32_ID_IN: u32 = 1610648044;
pub const SYSCALL_cx_rng_u32_ID_OUT: u32 = 2415954388;
pub const SYSCALL_os_sched_last_status_ID_IN: u32 = 1610652811;
pub const SYSCALL_os_sched_last_status_ID_OUT: u32 = 2415959149;
pub const SYSCALL_os_sched_yield_ID_IN: u32 = 1610653118;
pub const SYSCALL_os_sched_yield_ID_OUT: u32 = 2415959341;
pub const SYSCALL_os_sched_switch_ID_IN: u32 = 1610653213;
pub const SYSCALL_os_sched_switch_ID_OUT: u32 = 2415959600;
pub const SYSCALL_os_sched_current_task_ID_IN: u32 = 1610648401;
pub const SYSCALL_os_sched_current_task_ID_OUT: u32 = 2415954928;
pub const SYSCALL_os_mpu_protect_ram_ID_IN: u32 = 1610648898;
pub const SYSCALL_os_mpu_protect_ram_ID_OUT: u32 = 2415955328;
pub const SYSCALL_os_mpu_protect_flash_ID_IN: u32 = 1610649335;
pub const SYSCALL_os_mpu_protect_flash_ID_OUT: u32 = 2415955666;
pub const SYSCALL_PARAMETER_ARRAY_MAX_LEN: u32 = 12;
pub const BLE_CMD_APDU: u32 = 5;
pub const BLE_CHUNK_LENGTH: u32 = 20;
pub const M24SR_CHUNK_LENGTH: u32 = 246;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_REQBLE: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_RECOVERY: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_USB: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BLE: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_TOUCH: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT: u32 = 240;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT_POS: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_MASK: u32 = 3840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_NO_SCREEN: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_BIG: u32 = 256;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SML: u32 = 512;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_LEDRGB: u32 = 4096;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BATTERY: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MASK: u32 = 4026531840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_BASIC: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUSEC: u32 = 268435456;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUBL: u32 = 536870912;
pub const SEPROXYHAL_TAG_BLE_PAIRING_ATTEMPT_EVENT: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_WRITE_REQUEST_EVENT: u32 = 3;
pub const SEPROXYHAL_TAG_BLE_READ_REQUEST_EVENT: u32 = 4;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: u32 = 5;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_ID_MASK: u32 = 254;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_INTERVAL_MS: u32 = 100;
pub const SEPROXYHAL_TAG_NFC_FIELD_DETECTION_EVENT: u32 = 6;
pub const SEPROXYHAL_TAG_NFC_APDU_RECEIVED_EVENT: u32 = 7;
pub const SEPROXYHAL_TAG_BATTERY_NOTIFICATION_EVENT: u32 = 8;
pub const SEPROXYHAL_TAG_M24SR_GPO_CHANGE_EVENT: u32 = 9;
pub const SEPROXYHAL_TAG_M24SR_RESPONSE_APDU_EVENT: u32 = 10;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_EVENT: u32 = 11;
pub const SEPROXYHAL_TAG_FINGER_EVENT: u32 = 12;
pub const SEPROXYHAL_TAG_FINGER_EVENT_TOUCH: u32 = 1;
pub const SEPROXYHAL_TAG_FINGER_EVENT_RELEASE: u32 = 2;
pub const SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT: u32 = 13;
pub const SEPROXYHAL_TAG_TICKER_EVENT: u32 = 14;
pub const SEPROXYHAL_TAG_USB_EVENT: u32 = 15;
pub const SEPROXYHAL_TAG_USB_EVENT_RESET: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EVENT_SOF: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EVENT_SUSPENDED: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EVENT_RESUMED: u32 = 8;
pub const SEPROXYHAL_TAG_USB_EP_XFER_EVENT: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_XFER_SETUP: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EP_XFER_IN: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EP_XFER_OUT: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_CONNECTION_EVENT: u32 = 17;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_EVENT: u32 = 18;
pub const SEPROXYHAL_TAG_ACK_LINK_SPEED: u32 = 19;
pub const SEPROXYHAL_TAG_BLUENRG_RECV_EVENT: u32 = 20;
pub const SEPROXYHAL_TAG_STATUS_EVENT: u32 = 21;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING: u32 = 1;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_ON: u32 = 2;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BLE_ON: u32 = 4;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED: u32 = 8;
pub const SEPROXYHAL_TAG_CAPDU_EVENT: u32 = 22;
pub const SEPROXYHAL_TAG_I2C_EVENT: u32 = 23;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_READ: u32 = 1;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RECV_EVENT: u32 = 24;
pub const SEPROXYHAL_TAG_BOOTLOADER_RAPDU_EVENT: u32 = 25;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ: u32 = 50;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ_EXT: u32 = 51;
pub const SEPROXYHAL_TAG_BLE_SEND: u32 = 56;
pub const SEPROXYHAL_TAG_SET_SCREEN_CONFIG: u32 = 62;
pub const SEPROXYHAL_TAG_SET_LINK_PROP: u32 = 63;
pub const SEPROXYHAL_TAG_BLUENRG_SEND: u32 = 64;
pub const SEPROXYHAL_TAG_BLE_DEFINE_GENERIC_SETTING: u32 = 65;
pub const SEPROXYHAL_TAG_BLE_DEFINE_SERVICE_SETTING: u32 = 66;
pub const SEPROXYHAL_TAG_NFC_DEFINE_SERVICE_SETTING: u32 = 67;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER: u32 = 68;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_ON: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBWIPE: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBSAVE: u32 = 8;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBLOAD: u32 = 16;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBFREE: u32 = 32;
pub const SEPROXYHAL_TAG_NFC_RADIO_POWER: u32 = 69;
pub const SEPROXYHAL_TAG_SE_POWER_OFF: u32 = 70;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE: u32 = 72;
pub const SEPROXYHAL_TAG_BATTERY_CHARGE: u32 = 73;
pub const SEPROXYHAL_TAG_DEVICE_OFF: u32 = 75;
pub const SEPROXYHAL_TAG_MORE_TIME: u32 = 76;
pub const SEPROXYHAL_TAG_M24SR_C_APDU: u32 = 77;
pub const SEPROXYHAL_TAG_SET_TICKER_INTERVAL: u32 = 78;
pub const SEPROXYHAL_TAG_USB_CONFIG: u32 = 79;
pub const SEPROXYHAL_TAG_USB_CONFIG_CONNECT: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED: u32 = 0;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_CONTROL: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_BULK: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_ISOCHRONOUS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE: u32 = 80;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_SETUP: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN: u32 = 32;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT: u32 = 48;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL: u32 = 64;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL: u32 = 128;
pub const SEPROXYHAL_TAG_SET_LED: u32 = 81;
pub const SEPROXYHAL_TAG_REQUEST_STATUS: u32 = 82;
pub const SEPROXYHAL_TAG_RAPDU: u32 = 83;
pub const SEPROXYHAL_TAG_I2C_XFER: u32 = 84;
pub const SEPROXYHAL_TAG_PRINTF: u32 = 95;
pub const SEPROXYHAL_TAG_STATUS_MASK: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND: u32 = 0;
pub const SEPROXYHAL_TAG_PAIRING_STATUS: u32 = 97;
pub const SEPROXYHAL_TAG_BLE_READ_RESPONSE_STATUS: u32 = 98;
pub const SEPROXYHAL_TAG_NFC_READ_RESPONSE_STATUS: u32 = 99;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_STATUS: u32 = 100;
pub const SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS: u32 = 101;
pub const SEPROXYHAL_TAG_PRINTF_STATUS: u32 = 102;
pub const SEPROXYHAL_TAG_SET_LINK_SPEED: u32 = 103;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS: u32 = 104;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS_VERTICAL_SPLIT_SLIDE: u32 = 0;
pub const SEPROXYHAL_TAG_BOOTLOADER_CAPDU_STATUS: u32 = 106;
pub const UX_LAYOUT_PAGING_LINE: u32 = 1;
pub const BUTTON_FAST_THRESHOLD_CS: u32 = 8;
pub const BUTTON_FAST_ACTION_CS: u32 = 3;
pub const BUTTON_LEFT: u32 = 1;
pub const BUTTON_RIGHT: u32 = 2;
pub const BUTTON_EVT_FAST: u32 = 1073741824;
pub const BUTTON_EVT_RELEASED: u32 = 2147483648;
pub const UX_STACK_SLOT_COUNT: u32 = 1;
pub const UX_STACK_SLOT_ARRAY_COUNT: u32 = 1;
pub const UX_MENU_UNCHANGED_ENTRY: i32 = -1;
pub const UX_TURNER_UNCHANGED_ENTRY: i32 = -1;
pub const IO_CACHE: u32 = 1;
pub const NO_TIMEOUT: u32 = 0;
pub const bagl_components_type_e__BAGL_NONE: bagl_components_type_e_ = 0;
pub const bagl_components_type_e__BAGL_BUTTON: bagl_components_type_e_ = 1;
pub const bagl_components_type_e__BAGL_LABEL: bagl_components_type_e_ = 2;
pub const bagl_components_type_e__BAGL_RECTANGLE: bagl_components_type_e_ = 3;
pub const bagl_components_type_e__BAGL_LINE: bagl_components_type_e_ = 4;
pub const bagl_components_type_e__BAGL_ICON: bagl_components_type_e_ = 5;
pub const bagl_components_type_e__BAGL_CIRCLE: bagl_components_type_e_ = 6;
pub const bagl_components_type_e__BAGL_LABELINE: bagl_components_type_e_ = 7;
pub const bagl_components_type_e__BAGL_FLAG_TOUCHABLE: bagl_components_type_e_ = 128;
pub type bagl_components_type_e_ = cty::c_uint;
pub use self::bagl_components_type_e_ as bagl_components_type_e;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_component_t {
    pub type_: bagl_components_type_e,
    pub userid: cty::c_uchar,
    pub x: cty::c_short,
    pub y: cty::c_short,
    pub width: cty::c_ushort,
    pub height: cty::c_ushort,
    pub stroke: cty::c_uchar,
    pub radius: cty::c_uchar,
    pub fill: cty::c_uchar,
    pub fgcolor: cty::c_uint,
    pub bgcolor: cty::c_uint,
    pub font_id: cty::c_ushort,
    pub icon_id: cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_component_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_component_t>(),
        32usize,
        concat!("Size of: ", stringify!(bagl_component_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_component_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_component_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).userid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(userid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).width as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).stroke as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(stroke)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).radius as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).fill as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).fgcolor as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fgcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).bgcolor as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(bgcolor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).font_id as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_component_t>())).icon_id as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(icon_id)
        )
    );
}
#[doc = " helper structure to help handling icons"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_icon_details_s {
    pub width: cty::c_uint,
    pub height: cty::c_uint,
    pub bpp: cty::c_uint,
    pub colors: *const cty::c_uint,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_icon_details_s() {
    assert_eq!(
        ::core::mem::size_of::<bagl_icon_details_s>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_icon_details_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).bpp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).colors as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_icon_details_s>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bitmap)
        )
    );
}
#[doc = " helper structure to help handling icons"]
pub type bagl_icon_details_t = bagl_icon_details_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_font_character_t {
    pub char_width: cty::c_uchar,
    pub bitmap_byte_count: cty::c_uchar,
    pub bitmap_offset: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_bagl_font_character_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_font_character_t>(),
        4usize,
        concat!("Size of: ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_character_t>(),
        2usize,
        concat!("Alignment of ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).char_width as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(char_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).bitmap_byte_count as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_byte_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_font_character_t>())).bitmap_offset as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_font_t {
    pub font_id: cty::c_uint,
    pub bpp: cty::c_uchar,
    pub char_height: cty::c_uchar,
    pub baseline_height: cty::c_uchar,
    pub char_kerning: cty::c_uchar,
    pub first_char: cty::c_ushort,
    pub last_char: cty::c_ushort,
    pub characters: *const bagl_font_character_t,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_font_t() {
    assert_eq!(
        ::core::mem::size_of::<bagl_font_t>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_font_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_font_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).font_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).bpp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).char_height as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).baseline_height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(baseline_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).char_kerning as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_kerning)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).first_char as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(first_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).last_char as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(last_char)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).characters as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(characters)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_font_t>())).bitmap as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bitmap)
        )
    );
}
extern "C" {
    pub static mut C_bagl_fonts: [*const bagl_font_t; 0usize];
}
extern "C" {
    pub static C_bagl_fonts_count: cty::c_uint;
}
pub const bagl_font_id_e_BAGL_FONT_LUCIDA_CONSOLE_8PX: bagl_font_id_e = 0;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16_22PX: bagl_font_id_e = 1;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_8_11PX: bagl_font_id_e = 2;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_10_13PX: bagl_font_id_e = 3;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11_14PX: bagl_font_id_e = 4;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_13_18PX: bagl_font_id_e = 5;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_22_30PX: bagl_font_id_e = 6;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_8_11PX: bagl_font_id_e = 7;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_EXTRABOLD_11px: bagl_font_id_e = 8;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16px: bagl_font_id_e = 9;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11px: bagl_font_id_e = 10;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_10_13PX: bagl_font_id_e = 11;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_11_16PX: bagl_font_id_e = 12;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_13_18PX: bagl_font_id_e = 13;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_0: bagl_font_id_e = 14;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_1: bagl_font_id_e = 15;
pub const bagl_font_id_e_BAGL_FONT_LAST: bagl_font_id_e = 16;
pub type bagl_font_id_e = cty::c_uint;
pub const bagl_glyph_e_BAGL_GLYPH_NOGLYPH: bagl_glyph_e = 0;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_100: bagl_glyph_e = 1;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BLUE_120: bagl_glyph_e = 2;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_GEARS_50: bagl_glyph_e = 3;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CLEAR_16: bagl_glyph_e = 4;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BACKSPACE_20: bagl_glyph_e = 5;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK: bagl_glyph_e = 6;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS: bagl_glyph_e = 7;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK_BADGE: bagl_glyph_e = 8;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LEFT: bagl_glyph_e = 9;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_RIGHT: bagl_glyph_e = 10;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_UP: bagl_glyph_e = 11;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWN: bagl_glyph_e = 12;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_MINI: bagl_glyph_e = 13;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS_BADGE: bagl_glyph_e = 14;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DASHBOARD_BADGE: bagl_glyph_e = 15;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUS: bagl_glyph_e = 16;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LESS: bagl_glyph_e = 17;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_ON: bagl_glyph_e = 18;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_OFF: bagl_glyph_e = 19;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADING_BADGE: bagl_glyph_e = 20;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_COG_BADGE: bagl_glyph_e = 21;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_WARNING_BADGE: bagl_glyph_e = 22;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWNLOAD_BADGE: bagl_glyph_e = 23;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TRANSACTION_BADGE: bagl_glyph_e = 24;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BITCOIN_BADGE: bagl_glyph_e = 25;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_ETHEREUM_BADGE: bagl_glyph_e = 26;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_EYE_BADGE: bagl_glyph_e = 27;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PEOPLE_BADGE: bagl_glyph_e = 28;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOCK_BADGE: bagl_glyph_e = 29;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BLUE_CABLE: bagl_glyph_e = 30;
pub const bagl_glyph_e_BAGL_GLYPH_TEXT_WELCOME: bagl_glyph_e = 31;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BOOT: bagl_glyph_e = 32;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_LEFT: bagl_glyph_e = 33;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_RIGHT: bagl_glyph_e = 34;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LIGHTNING: bagl_glyph_e = 35;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUG: bagl_glyph_e = 36;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_DOWNLOAD_BLUE: bagl_glyph_e = 37;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WARNING_BLUE: bagl_glyph_e = 38;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADER_BLUE: bagl_glyph_e = 39;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CHECKMARK_BLUE: bagl_glyph_e = 40;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WRENCH_BLUE: bagl_glyph_e = 41;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ERROR_BLUE: bagl_glyph_e = 42;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_POWER_BLUE: bagl_glyph_e = 43;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CRITICAL_BLUE: bagl_glyph_e = 44;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ASSISTANCE_BLUE: bagl_glyph_e = 45;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_LOCK_BLUE: bagl_glyph_e = 46;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECKMARK_BLUE: bagl_glyph_e = 47;
pub const bagl_glyph_e_BAGL_GLYPH_APP_FIRMWARE_BLUE: bagl_glyph_e = 48;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_BLUE: bagl_glyph_e = 49;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_LOW_BLUE: bagl_glyph_e = 50;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_HIGH_BLUE: bagl_glyph_e = 51;
pub type bagl_glyph_e = cty::c_uint;
extern "C" {
    pub fn bagl_compute_line_width(
        font_id: cty::c_ushort,
        width: cty::c_ushort,
        text: *const cty::c_void,
        text_length: cty::c_uchar,
        text_encoding: cty::c_uchar,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn bagl_draw_string(
        font_id: cty::c_ushort,
        color1: cty::c_uint,
        color0: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        text: *const cty::c_void,
        text_length: cty::c_uint,
        text_encoding: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bagl_draw_bg(color: cty::c_uint);
}
extern "C" {
    pub fn bagl_draw_with_context(
        component: *const bagl_component_t,
        text: *const cty::c_void,
        text_length: cty::c_ushort,
        text_encoding: cty::c_uchar,
    );
}
extern "C" {
    pub fn bagl_draw(component: *const bagl_component_t);
}
extern "C" {
    pub fn bagl_draw_glyph(
        component: *const bagl_component_t,
        icon_details: *const bagl_icon_details_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_animated_s {
    pub c: bagl_component_t,
    pub text: *mut cty::c_void,
    pub text_length: cty::c_ushort,
    pub text_encoding: cty::c_uchar,
    pub current_char_idx: cty::c_uint,
    pub current_x: cty::c_uint,
    pub next_ms: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bagl_animated_s() {
    assert_eq!(
        ::core::mem::size_of::<bagl_animated_s>(),
        52usize,
        concat!("Size of: ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_animated_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text_length as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).text_encoding as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_encoding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bagl_animated_s>())).current_char_idx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_char_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).current_x as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_animated_s>())).next_ms as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(next_ms)
        )
    );
}
pub type bagl_animated_t = bagl_animated_s;
extern "C" {
    pub fn bagl_animate(
        anim: *mut bagl_animated_t,
        timestamp_ms: cty::c_uint,
        interval_ms: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_within_rect(
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        color_count: cty::c_uint,
        colors: *const cty::c_uint,
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_continue(
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_rect(
        color: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_action(component: *const bagl_component_t, event_kind: cty::c_uchar);
}
#[doc = "< 2 Non Maskable Interrupt"]
pub const IRQn_Type_NonMaskableInt_IRQn: IRQn_Type = -14;
#[doc = "< 4 Cortex-M Memory Management Interrupt"]
pub const IRQn_Type_HardFault_IRQn: IRQn_Type = -13;
#[doc = "< 4 Cortex-M Memory Management Interrupt"]
pub const IRQn_Type_MemoryManagement_IRQn: IRQn_Type = -12;
#[doc = "< 5 Cortex-M Bus Fault Interrupt"]
pub const IRQn_Type_BusFault_IRQn: IRQn_Type = -11;
#[doc = "< 6 Cortex-M Usage Fault Interrupt"]
pub const IRQn_Type_UsageFault_IRQn: IRQn_Type = -10;
#[doc = "< 11 Cortex-M SV Call Interrupt"]
pub const IRQn_Type_SVC_IRQn: IRQn_Type = -5;
#[doc = "< 12 Cortex-M Debug Monitor Interrupt"]
pub const IRQn_Type_DebugMonitor_IRQn: IRQn_Type = -4;
#[doc = "< 14 Cortex-M Pend SV Interrupt"]
pub const IRQn_Type_PendSV_IRQn: IRQn_Type = -2;
#[doc = "< 15 Cortex-M System Tick Interrupt"]
pub const IRQn_Type_SysTick_IRQn: IRQn_Type = -1;
pub type IRQn_Type = cty::c_int;
#[doc = " Quality development guidelines:"]
#[doc = " - NO header defined per arch and included in common if needed per arch,"]
#[doc = " define below"]
#[doc = " - exception model"]
#[doc = " - G_ prefix for RAM vars"]
#[doc = " - N_ prefix for NVRAM vars (mandatory for x86 link script to operate"]
#[doc = " correctly)"]
#[doc = " - C_ prefix for ROM   constants (mandatory for x86 link script to operate"]
#[doc = " correctly)"]
#[doc = " - extensive use of * and arch specific C modifier"]
pub type exception_t = cty::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [cty::c_uint; 10usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
#[test]
fn bindgen_test_layout_try_context_s() {
    assert_eq!(
        ::core::mem::size_of::<try_context_s>(),
        48usize,
        concat!("Size of: ", stringify!(try_context_s))
    );
    assert_eq!(
        ::core::mem::align_of::<try_context_s>(),
        4usize,
        concat!("Alignment of ", stringify!(try_context_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).jmp_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).previous as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<try_context_s>())).ex as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(ex)
        )
    );
}
extern "C" {
    pub fn longjmp(__jmpb: *mut cty::c_uint, __retval: cty::c_int);
}
extern "C" {
    pub fn setjmp(__jmpb: *mut cty::c_uint) -> cty::c_int;
}
pub type size_t = cty::c_uint;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = cty::c_longlong;
pub type uintmax_t = cty::c_ulonglong;
#[doc = " \\brief  Union type to access the Application Program Status Register (APSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: APSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<APSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Interrupt Program Status Register (IPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: IPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<IPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Special-Purpose Program Status Registers (xPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: xPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        T: u32,
        IT: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let IT: u32 = unsafe { ::core::mem::transmute(IT) };
            IT as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xPSR_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Control Registers (CONTROL)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: CONTROL_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        _reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CONTROL_Type>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NVIC_Type {
    #[doc = "< Offset: 0x000 (R/W)  Interrupt Set Enable Register"]
    pub ISER: [u32; 1usize],
    pub RESERVED0: [u32; 31usize],
    #[doc = "< Offset: 0x080 (R/W)  Interrupt Clear Enable Register"]
    pub ICER: [u32; 1usize],
    pub RSERVED1: [u32; 31usize],
    #[doc = "< Offset: 0x100 (R/W)  Interrupt Set Pending Register"]
    pub ISPR: [u32; 1usize],
    pub RESERVED2: [u32; 31usize],
    #[doc = "< Offset: 0x180 (R/W)  Interrupt Clear Pending Register"]
    pub ICPR: [u32; 1usize],
    pub RESERVED3: [u32; 31usize],
    pub RESERVED4: [u32; 64usize],
    #[doc = "< Offset: 0x300 (R/W)  Interrupt Priority Register"]
    pub IP: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        800usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISER as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICER as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RSERVED1 as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RSERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ISPR as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED2 as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).ICPR as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED3 as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).RESERVED4 as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<NVIC_Type>())).IP as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
}
#[doc = " \\brief  Structure type to access the System Control Block (SCB)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SCB_Type {
    #[doc = "< Offset: 0x000 (R/ )  CPUID Base Register"]
    pub CPUID: u32,
    #[doc = "< Offset: 0x004 (R/W)  Interrupt Control and State Register"]
    pub ICSR: u32,
    #[doc = "< Offset: 0x008 (R/W)  Vector Table Offset Register"]
    pub VTOR: u32,
    #[doc = "< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register"]
    pub AIRCR: u32,
    #[doc = "< Offset: 0x010 (R/W)  System Control Register"]
    pub SCR: u32,
    #[doc = "< Offset: 0x014 (R/W)  Configuration Control Register"]
    pub CCR: u32,
    pub RESERVED0: [u32; 1usize],
    #[doc = "< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED"]
    pub SHP: [u32; 2usize],
    #[doc = "< Offset: 0x024 (R/W)  System Handler Control and State Register"]
    pub SHCSR: u32,
    pub RESERVED1: [u32; 154usize],
    #[doc = "< Offset: 0x290 (R/W)  Security Features Register"]
    pub SFCR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        660usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CPUID as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).ICSR as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).VTOR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).AIRCR as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SCR as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).CCR as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED0 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHP as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SHCSR as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).RESERVED1 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCB_Type>())).SFCR as *const _ as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SFCR)
        )
    );
}
#[doc = " \\brief  Structure type to access the System Control and ID Register not in the SCB."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCnSCB_Type {
    pub RESERVED0: [u32; 2usize],
    #[doc = "< Offset: 0x008 (R/W)  Auxiliary Control Register"]
    pub ACTLR: u32,
}
#[test]
fn bindgen_test_layout_SCnSCB_Type() {
    assert_eq!(
        ::core::mem::size_of::<SCnSCB_Type>(),
        12usize,
        concat!("Size of: ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCnSCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCnSCB_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).RESERVED0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SCnSCB_Type>())).ACTLR as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCnSCB_Type),
            "::",
            stringify!(ACTLR)
        )
    );
}
#[doc = " \\brief  Structure type to access the System Timer (SysTick)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysTick_Type {
    #[doc = "< Offset: 0x000 (R/W)  SysTick Control and Status Register"]
    pub CTRL: u32,
    #[doc = "< Offset: 0x004 (R/W)  SysTick Reload Value Register"]
    pub LOAD: u32,
    #[doc = "< Offset: 0x008 (R/W)  SysTick Current Value Register"]
    pub VAL: u32,
    #[doc = "< Offset: 0x00C (R/ )  SysTick Calibration Register"]
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CTRL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).LOAD as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).VAL as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SysTick_Type>())).CALIB as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
extern "C" {
    pub fn pic(linked_address: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub static mut G_io_apdu_buffer: [cty::c_uchar; 260usize];
}
extern "C" {
    pub fn app_main();
}
extern "C" {
    pub fn os_boot();
}
extern "C" {
    pub fn os_memmove(dst: *mut cty::c_void, src: *const cty::c_void, length: cty::c_uint);
}
extern "C" {
    pub fn os_memset(dst: *mut cty::c_void, c: cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_memset4(dst: *mut cty::c_void, initval: cty::c_uint, nbintval: cty::c_uint);
}
extern "C" {
    pub fn os_memcmp(
        buf1: *const cty::c_void,
        buf2: *const cty::c_void,
        length: cty::c_uint,
    ) -> cty::c_char;
}
extern "C" {
    pub fn os_xor(
        dst: *mut cty::c_void,
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_secure_memcmp(
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    ) -> cty::c_char;
}
extern "C" {
    pub fn patch();
}
extern "C" {
    pub fn check_api_level(apiLevel: cty::c_uint);
}
extern "C" {
    pub fn halt();
}
extern "C" {
    pub fn io_exchange(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
pub const io_apdu_media_t_IO_APDU_MEDIA_NONE: io_apdu_media_t = 0;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_HID: io_apdu_media_t = 1;
pub const io_apdu_media_t_IO_APDU_MEDIA_BLE: io_apdu_media_t = 2;
pub const io_apdu_media_t_IO_APDU_MEDIA_NFC: io_apdu_media_t = 3;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_CCID: io_apdu_media_t = 4;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_WEBUSB: io_apdu_media_t = 5;
pub const io_apdu_media_t_IO_APDU_MEDIA_RAW: io_apdu_media_t = 6;
pub const io_apdu_media_t_IO_APDU_MEDIA_U2F: io_apdu_media_t = 7;
pub type io_apdu_media_t = cty::c_uint;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [cty::c_uchar; 64usize];
}
extern "C" {
    #[doc = " Return 1 when the event has been processed, 0 else"]
    pub fn io_event(channel: cty::c_uchar) -> cty::c_uchar;
}
extern "C" {
    #[doc = " Function takes 0 for first call. Returns 0 when timeout has occured. Returned"]
    #[doc = " value is passed as argument for next call, acting as a timeout context."]
    pub fn io_timeout(last_timeout: cty::c_ushort) -> cty::c_ushort;
}
extern "C" {
    pub fn nvm_write(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
}
extern "C" {
    pub fn nvm_write_os(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
}
extern "C" {
    pub fn nvm_write_page(page_adr: *mut cty::c_uchar);
}
extern "C" {
    pub fn svc_nvm_write_page(page_adr: *mut cty::c_uchar);
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn svc_try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn svc_try_context_set(tryctx: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: cty::c_uint);
}
pub type uint64bits_t = u64;
extern "C" {
    #[doc = " Generate a random unsigned byte between 0 and 255"]
    #[doc = ""]
    #[doc = " @return a random byte."]
    pub fn cx_rng_u8() -> cty::c_uchar;
}
pub type cx_rng_u32_range_randfunc_t = ::core::option::Option<unsafe extern "C" fn() -> u32>;
extern "C" {
    #[doc = " Generate a random 32 bits unsigned integer in range [a;b[ with uniform"]
    #[doc = " probability."]
    #[doc = ""]
    #[doc = " @param [in] a        inclusive low bound"]
    #[doc = " @param [in] b        exclusive high bound"]
    #[doc = " @param [in] randfunc function called to generate random u32 value"]
    #[doc = ""]
    #[doc = " @return generated random."]
    pub fn cx_rng_u32_range_func(a: u32, b: u32, randfunc: cx_rng_u32_range_randfunc_t) -> u32;
}
extern "C" {
    #[doc = " Generate a random 32 bits unsigned integer in range [a;b[ with unform"]
    #[doc = " probality."]
    #[doc = ""]
    #[doc = " @param [in] a   inclusive low bound"]
    #[doc = " @param [in] b   exclusive high bound"]
    #[doc = ""]
    #[doc = " @return generated random."]
    pub fn cx_rng_u32_range(a: u32, b: u32) -> u32;
}
extern "C" {
    #[doc = " Generate 32 bits of random. This function is implemented as a SUDOCALL to"]
    #[doc = " allow calls from constrained tasks (IO sometimes needs random numbers)."]
    #[doc = " @return a random 32bits."]
    pub fn cx_rng_u32() -> cty::c_uint;
}
extern "C" {
    pub fn svc_cx_rng_u32() -> cty::c_uint;
}
extern "C" {
    #[doc = " Generate a random buffer, each bytes between 0 and 255*"]
    #[doc = ""]
    #[doc = " @param [out] buffer to randomize"]
    #[doc = " @param [in]  buffer length"]
    pub fn cx_rng(buffer: *mut cty::c_uchar, len: cty::c_uint) -> *mut cty::c_uchar;
}
#[doc = " NONE Digest"]
pub const cx_md_e_CX_NONE: cx_md_e = 0;
#[doc = " RIPEMD160 Digest"]
pub const cx_md_e_CX_RIPEMD160: cx_md_e = 1;
#[doc = " SHA224 Digest"]
pub const cx_md_e_CX_SHA224: cx_md_e = 2;
#[doc = " SHA256 Digest"]
pub const cx_md_e_CX_SHA256: cx_md_e = 3;
#[doc = " SHA384 Digest"]
pub const cx_md_e_CX_SHA384: cx_md_e = 4;
#[doc = " SHA512 Digest"]
pub const cx_md_e_CX_SHA512: cx_md_e = 5;
#[doc = " Keccak (pre-SHA3) Digest"]
pub const cx_md_e_CX_KECCAK: cx_md_e = 6;
#[doc = " SHA3 Digest"]
pub const cx_md_e_CX_SHA3: cx_md_e = 7;
#[doc = " Groestl Digest"]
pub const cx_md_e_CX_GROESTL: cx_md_e = 8;
#[doc = " Blake Digest"]
pub const cx_md_e_CX_BLAKE2B: cx_md_e = 9;
#[doc = " SHAKE-128 Digest"]
pub const cx_md_e_CX_SHAKE128: cx_md_e = 10;
#[doc = " SHAKE-128 Digest"]
pub const cx_md_e_CX_SHAKE256: cx_md_e = 11;
#[doc = " Message Digest algorithm identifiers."]
pub type cx_md_e = cty::c_uint;
#[doc = " Convenience type. See #cx_md_e."]
pub use self::cx_md_e as cx_md_t;
#[doc = " Common Message Digest context, used as abstract type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_header_s {
    #[doc = " Message digest identifier, See cx_md_e."]
    pub algo: cx_md_t,
    #[doc = " Number of block already processed"]
    pub counter: cty::c_uint,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).algo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_header_s>())).counter as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
#[doc = " Convenience type. See #cx_hash_header_s."]
pub type cx_hash_t = cx_hash_header_s;
extern "C" {
    #[doc = " Add more data to hash."]
    #[doc = ""]
    #[doc = " @param  [in/out] hash"]
    #[doc = "   Univers Continuation Blob."]
    #[doc = "   The hash context pointer shall point to a well-defined hash struct"]
    #[doc = " cx_ripemd160_t, cx_sha256_t, .... The hash context shall be inited with"]
    #[doc = " 'cx_xxx_init' The hash context shall be in RAM The function should be called"]
    #[doc = " with a nice cast."]
    #[doc = ""]
    #[doc = " @param  [in] mode"]
    #[doc = "   Supported flags: CX_LAST"]
    #[doc = "   If CX_LAST is set,"]
    #[doc = "     - The struct is left not modified after finishing"]
    #[doc = "     - if out is provided, hash is copied in out"]
    #[doc = "     - context is NOT automatically re-inited."]
    #[doc = ""]
    #[doc = " @param  [in] in"]
    #[doc = "   Input data to add to current hash"]
    #[doc = ""]
    #[doc = " @param  [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   Either:"]
    #[doc = "     - NULL (ignored) if CX_LAST is NOT set"]
    #[doc = "     - produced hash  if CX_LAST is set"]
    #[doc = ""]
    #[doc = " @param [out] out_len"]
    #[doc = "   Either:"]
    #[doc = "     - O, if out is NULL"]
    #[doc = "     - out buffer size, if buffer is too small to store the hash a exception"]
    #[doc = " is thrown"]
    #[doc = ""]
    pub fn cx_hash(
        hash: *mut cx_hash_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " RIPEMD-160 context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ripemd160_s {
    #[doc = " See #cx_hash_header_s"]
    pub header: cx_hash_header_s,
    #[doc = " @internal"]
    #[doc = " pending partial block length"]
    pub blen: cty::c_uint,
    #[doc = " @internal"]
    #[doc = " pending partial block"]
    pub block: [cty::c_uchar; 64usize],
    #[doc = " Current digest state."]
    #[doc = " After finishing the digest, contains the digest if correct parameters are"]
    #[doc = " passed."]
    pub acc: [cty::c_uchar; 20usize],
}
#[test]
fn bindgen_test_layout_cx_ripemd160_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ripemd160_s>(),
        96usize,
        concat!("Size of: ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ripemd160_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ripemd160_s>())).acc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(acc)
        )
    );
}
#[doc = " Convenience type. See #cx_ripemd160_s."]
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    #[doc = " Initialize a RIPEMD-160 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_ripemd160_init(hash: *mut cx_ripemd160_t) -> cty::c_int;
}
#[doc = " SHA-224 and SHA-256 context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha256_s {
    #[doc = " @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = " @internal @copydoc cx_ripemd160_s::blen"]
    pub blen: cty::c_uint,
    #[doc = " @internal @copydoc cx_ripemd160_s::block"]
    pub block: [cty::c_uchar; 64usize],
    #[doc = " @copydoc cx_ripemd160_s::acc"]
    pub acc: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha256_s>())).acc as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
#[doc = " Convenience type. See #cx_sha256_s."]
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    #[doc = " Initialize a SHA-224 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha224_init(hash: *mut cx_sha256_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a SHA-256 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha256_init(hash: *mut cx_sha256_t) -> cty::c_int;
}
extern "C" {
    #[doc = " One shot SHA-256 digest"]
    #[doc = ""]
    #[doc = " @param  [in] in"]
    #[doc = "   Input data to compute the hash"]
    #[doc = ""]
    #[doc = " @param  [in] len"]
    #[doc = "   Length of input data."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   'out' length is implicit"]
    #[doc = ""]
    pub fn cx_hash_sha256(
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " KECCAK, SHA3 and SHA3-XOF context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha3_s {
    #[doc = " @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = " @internal output digest size"]
    pub output_size: cty::c_uint,
    #[doc = " @internal input block size"]
    pub block_size: cty::c_uint,
    #[doc = " @internal @copydoc cx_ripemd160_s::blen"]
    pub blen: cty::c_uint,
    #[doc = " @internal @copydoc cx_ripemd160_s::block"]
    pub block: [cty::c_uchar; 200usize],
    #[doc = " @copydoc cx_ripemd160_s::acc"]
    pub acc: [uint64bits_t; 25usize],
}
#[test]
fn bindgen_test_layout_cx_sha3_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha3_s>(),
        424usize,
        concat!("Size of: ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha3_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).block_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).blen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).block as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha3_s>())).acc as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(acc)
        )
    );
}
#[doc = " Convenience type. See #cx_sha3_s."]
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    #[doc = " Initialize a sha3 context."]
    #[doc = ""]
    #[doc = " SHA3 family as specified in FIPS 202."]
    #[doc = " Supported output sizes are: 224,256,384,512"]
    #[doc = ""]
    #[doc = " @param [out] hash  the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] size   output sha3 size, in BITS."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha3_init(hash: *mut cx_sha3_t, size: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a sha3 context."]
    #[doc = ""]
    #[doc = " SHA3 family as specified in Keccak submission."]
    #[doc = " Supported output sizes are: 224,256,384,512"]
    #[doc = ""]
    #[doc = " @param [out] hash  the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] size   output sha3 size, in BITS."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_keccak_init(hash: *mut cx_sha3_t, size: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Init a sha3-XOF context."]
    #[doc = ""]
    #[doc = " SHA3-XOF family as specified in FIPS 202."]
    #[doc = " Supported output sha3 sizes are: 256,512"]
    #[doc = ""]
    #[doc = " @param [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] out_size         desired output size, in BITS."]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_shake128_init(hash: *mut cx_sha3_t, out_size: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Init a sha3-XOF context."]
    #[doc = ""]
    #[doc = " SHA3-XOF family as specified in FIPS 202."]
    #[doc = " Supported output sha3 sizes are: 256,512"]
    #[doc = ""]
    #[doc = " @param [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] out_size   desired output size, in BITS."]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_shake256_init(hash: *mut cx_sha3_t, out_size: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " @deprecated"]
    #[doc = ""]
    #[doc = " Init a sha3-XOF context."]
    #[doc = ""]
    #[doc = " SHA3-XOF family as specified in FIPS 202."]
    #[doc = " Supported output sha3 sizes are: 256,512"]
    #[doc = ""]
    #[doc = " @param [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] size         output sha3 size, in BITS."]
    #[doc = " @param [in] out_length   desired output size, in BYTES."]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha3_xof_init(
        hash: *mut cx_sha3_t,
        size: cty::c_uint,
        out_length: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " SHA-384 and SHA-512 context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_sha512_s {
    #[doc = " @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = " @internal @copydoc cx_ripemd160_s::blen"]
    pub blen: cty::c_uint,
    #[doc = " @internal @copydoc cx_ripemd160_s::block"]
    pub block: [cty::c_uchar; 128usize],
    #[doc = " @copydoc cx_ripemd160_s::acc"]
    pub acc: [cty::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).blen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).block as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_sha512_s>())).acc as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
#[doc = " Convenience type. See #cx_sha512_s."]
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    #[doc = " Initialize a SHA-384 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to initialize."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha384_init(hash: *mut cx_sha512_t) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a SHA-512 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to initialize."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_sha512_init(hash: *mut cx_sha512_t) -> cty::c_int;
}
extern "C" {
    #[doc = " One shot SHA-512 digest"]
    #[doc = ""]
    #[doc = " @param  [in] in"]
    #[doc = "   Input data to compute the hash"]
    #[doc = ""]
    #[doc = " @param  [in] len"]
    #[doc = "   Length of input data."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   'out' length is implicit"]
    #[doc = ""]
    pub fn cx_hash_sha512(
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
pub const blake2b_constant_BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
pub const blake2b_constant_BLAKE2B_OUTBYTES: blake2b_constant = 64;
pub const blake2b_constant_BLAKE2B_KEYBYTES: blake2b_constant = 64;
pub const blake2b_constant_BLAKE2B_SALTBYTES: blake2b_constant = 16;
pub const blake2b_constant_BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
#[doc = "  @private"]
pub type blake2b_constant = cty::c_uint;
#[doc = "  @private"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blake2b_state__ {
    pub h: [u64; 8usize],
    pub t: [u64; 2usize],
    pub f: [u64; 2usize],
    pub buf: [u8; 128usize],
    pub buflen: size_t,
    pub outlen: size_t,
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).h as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).t as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).f as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buf as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).buflen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).outlen as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blake2b_state__>())).last_node as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
#[doc = " @private"]
pub type blake2b_state = blake2b_state__;
#[doc = " Blake2b context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_blake2b_s {
    #[doc = " @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = " @internal output digest size"]
    pub output_size: cty::c_uint,
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_blake2b_s>())).ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
#[doc = " Convenience type. See #cx_blake2b_s."]
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    #[doc = " Init a blake2b context."]
    #[doc = ""]
    #[doc = " Blake2b as specified at https://blake2.net."]
    #[doc = ""]
    #[doc = " @param [out] hash  the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] size   output blake2b size, in BITS."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_blake2b_init(hash: *mut cx_blake2b_t, out_len: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Init a blake2b context with salt and personalization string."]
    #[doc = ""]
    #[doc = " Blake2b as specified at https://blake2.net."]
    #[doc = ""]
    #[doc = " @param [out] hash  the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] size   output blake2b size, in BITS."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_blake2b_init2(
        hash: *mut cx_blake2b_t,
        out_len: cty::c_uint,
        salt: *mut cty::c_uchar,
        salt_len: cty::c_uint,
        perso: *mut cty::c_uchar,
        perso_len: cty::c_uint,
    ) -> cty::c_int;
}
pub type BitSequence = cty::c_uchar;
#[doc = "  @Private"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hashState_s {
    pub chaining: [[u8; 16usize]; 8usize],
    pub block_counter: u64,
    pub hashlen: cty::c_uint,
    pub buffer: [BitSequence; 128usize],
    pub buf_ptr: cty::c_uint,
    pub columns: cty::c_uint,
    pub rounds: cty::c_uint,
    pub statesize: cty::c_uint,
}
#[test]
fn bindgen_test_layout_hashState_s() {
    assert_eq!(
        ::core::mem::size_of::<hashState_s>(),
        288usize,
        concat!("Size of: ", stringify!(hashState_s))
    );
    assert_eq!(
        ::core::mem::align_of::<hashState_s>(),
        8usize,
        concat!("Alignment of ", stringify!(hashState_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).chaining as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(chaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).block_counter as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(block_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).hashlen as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(hashlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).buffer as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).buf_ptr as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).columns as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).rounds as *const _ as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(rounds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hashState_s>())).statesize as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(hashState_s),
            "::",
            stringify!(statesize)
        )
    );
}
#[doc = " @Private"]
pub type hashState = hashState_s;
#[doc = " Groestl context"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_groestl_s {
    #[doc = " @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = " @internal output digest size"]
    pub output_size: cty::c_uint,
    pub ctx: hashState_s,
}
#[test]
fn bindgen_test_layout_cx_groestl_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_groestl_s>(),
        304usize,
        concat!("Size of: ", stringify!(cx_groestl_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_groestl_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_groestl_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).output_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_groestl_s>())).ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_groestl_s),
            "::",
            stringify!(ctx)
        )
    );
}
#[doc = " Convenience type. See #cx_groestl512_s."]
pub type cx_groestl_t = cx_groestl_s;
extern "C" {
    #[doc = " Init a groestl224 context."]
    #[doc = ""]
    #[doc = " @param [out] hash the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @return algorithm identifier"]
    pub fn cx_groestl_init(hash: *mut cx_groestl_t, size: cty::c_uint) -> cty::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cx_hash_for_hmac_ctx {
    pub header: cx_hash_t,
    pub sha256: cx_sha256_t,
    pub sha512: cx_sha512_t,
    pub ripemd160: cx_ripemd160_t,
}
#[test]
fn bindgen_test_layout_cx_hash_for_hmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cx_hash_for_hmac_ctx>(),
        204usize,
        concat!("Size of: ", stringify!(cx_hash_for_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_for_hmac_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_for_hmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).sha256 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(sha256)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).sha512 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(sha512)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hash_for_hmac_ctx>())).ripemd160 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_for_hmac_ctx),
            "::",
            stringify!(ripemd160)
        )
    );
}
#[doc = " HMAC context."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_hmac_ctx {
    pub hash_ctx: cx_hash_for_hmac_ctx,
    pub key: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_hmac_ctx() {
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_ctx>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_ctx>())).hash_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ctx),
            "::",
            stringify!(hash_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_hmac_ctx>())).key as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ctx),
            "::",
            stringify!(key)
        )
    );
}
pub type cx_hmac_t = cx_hmac_ctx;
pub type cx_hmac_ripemd160_t = cx_hmac_ctx;
pub type cx_hmac_sha256_t = cx_hmac_ctx;
pub type cx_hmac_sha512_t = cx_hmac_ctx;
extern "C" {
    #[doc = " Init a hmac sha512 context."]
    #[doc = ""]
    #[doc = " @param  [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param  [in] key         hmac key value"]
    #[doc = "    Passing a NULL pointeur, will reinit the context with the previously set"]
    #[doc = " key. If no key has already been set, passing NULL will lead into an undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param  [in] key_len     hmac key length"]
    #[doc = "    The key length shall be less than 64 bytes"]
    #[doc = ""]
    #[doc = " @return algorithm  identifier"]
    pub fn cx_hmac_ripemd160_init(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Init a hmac sha256 context."]
    #[doc = ""]
    #[doc = " @param [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] key         hmac key value"]
    #[doc = "    Passing a NULL pointeur, will reinit the context with the previously set"]
    #[doc = " key. If no key has already been set, passing NULL will lead into an undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param [in] key_len     hmac key length"]
    #[doc = "    The key length shall be less than 64 bytes"]
    #[doc = ""]
    #[doc = " @return algorithm  identifier"]
    pub fn cx_hmac_sha256_init(
        hmac: *mut cx_hmac_sha256_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Init a hmac sha512 context."]
    #[doc = ""]
    #[doc = " @param [out] hash        the context to init."]
    #[doc = "    The context shall be in RAM"]
    #[doc = ""]
    #[doc = " @param [in] key         hmac key value"]
    #[doc = "    Passing a NULL pointeur, will reinit the context with the previously set"]
    #[doc = " key. If no key has already been set, passing NULL will lead into an undefined"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param [in] key_len     hmac key length"]
    #[doc = "    The key length shall be less than 128 bytes"]
    #[doc = ""]
    #[doc = " @return algorithm  identifier"]
    pub fn cx_hmac_sha512_init(
        hmac: *mut cx_hmac_sha512_t,
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " @param [in,out] hmac"]
    #[doc = "   Univers Continuation Blob."]
    #[doc = "   The hmac context pointer shall point to  either a cx_ripemd160_t, either a"]
    #[doc = " cx_sha256_t  or cx_sha512_t . The hmac context shall be inited with"]
    #[doc = " 'cx_xxx_init' The hmac context shall be in RAM The function should be called"]
    #[doc = " with a nice cast."]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See Above."]
    #[doc = "   If CX_LAST is set and CX_NO_REINIT is not set, context is automatically"]
    #[doc = " re-inited. Supported flags:"]
    #[doc = "     - CX_LAST"]
    #[doc = "     - CX_NO_REINIT"]
    #[doc = ""]
    #[doc = " @param [in] in"]
    #[doc = "   Input data to add to current hmac"]
    #[doc = ""]
    #[doc = " @param [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] mac"]
    #[doc = "   Either:"]
    #[doc = "     - NULL (ignored) if CX_LAST is NOT set"]
    #[doc = "     - produced hmac  if CX_LAST is set"]
    #[doc = ""]
    #[doc = " @param [in] mac_len"]
    #[doc = "   Either:"]
    #[doc = "     - O, if mac is NULL"]
    #[doc = "     - mac buffer size, if buffer is too small to store the mac an exception"]
    #[doc = " is thrown"]
    #[doc = ""]
    pub fn cx_hmac(
        hmac: *mut cx_hmac_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " One shot hmac sha512 digest"]
    #[doc = ""]
    #[doc = " @param  [in] key_in"]
    #[doc = "   hmac key value"]
    #[doc = ""]
    #[doc = " @param  [in] key_len"]
    #[doc = "   Length of the hmac key"]
    #[doc = ""]
    #[doc = " @param  [in] in"]
    #[doc = "   Input data to compute the hash"]
    #[doc = ""]
    #[doc = " @param  [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   Produced hmac"]
    #[doc = ""]
    #[doc = " @param [in] mac_len"]
    #[doc = "    mac buffer size, if buffer is too small to store the mac an exception is"]
    #[doc = " thrown"]
    pub fn cx_hmac_sha512(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " One shot hmac sha256 digest"]
    #[doc = ""]
    #[doc = " @param  [in] key_in"]
    #[doc = "   hmac key value"]
    #[doc = ""]
    #[doc = " @param  [in] key_len"]
    #[doc = "   Length of the hmac key"]
    #[doc = ""]
    #[doc = " @param  [in] in"]
    #[doc = "   Input data to compute the hash"]
    #[doc = ""]
    #[doc = " @param  [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   Produced hmac"]
    #[doc = ""]
    #[doc = " @param [in] mac_len"]
    #[doc = "    mac buffer size, if buffer is too small to store the mac an exception is"]
    #[doc = " thrown"]
    pub fn cx_hmac_sha256(
        key: *const cty::c_uchar,
        key_len: cty::c_uint,
        in_: *const cty::c_uchar,
        len: cty::c_uint,
        mac: *mut cty::c_uchar,
        mac_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compute pbkdf2 bytes sequence as specified by RFC 2898."]
    #[doc = ""]
    #[doc = " @param [in]  md_type"]
    #[doc = "    The hash algo (CX_SHA512, CX_SHA256, ...)"]
    #[doc = ""]
    #[doc = " @param [in]  password"]
    #[doc = "    The hmac key"]
    #[doc = ""]
    #[doc = " @param [in]  passwordlen"]
    #[doc = "    The hmac key bytes length"]
    #[doc = ""]
    #[doc = " @param [in]  salt"]
    #[doc = "    The initial salt."]
    #[doc = ""]
    #[doc = " @param [in]  saltlen"]
    #[doc = "    The salt key bytes length"]
    #[doc = ""]
    #[doc = " @param [in]  iterations"]
    #[doc = "    Per block iteration."]
    #[doc = ""]
    #[doc = " @param [in]  out"]
    #[doc = "    Where to put result."]
    #[doc = ""]
    #[doc = " @param [in] outLength"]
    #[doc = "    How many bytes to generate."]
    #[doc = ""]
    pub fn cx_pbkdf2(
        md_type: cx_md_t,
        password: *const cty::c_uchar,
        passwordlen: cty::c_ushort,
        salt: *mut cty::c_uchar,
        saltlen: cty::c_ushort,
        iterations: cty::c_uint,
        out: *mut cty::c_uchar,
        outLength: cty::c_uint,
    );
}
#[doc = " DES key container."]
#[doc = "  Such container should be initialize with cx_des_init_key to ensure future"]
#[doc = " API compatibility. Indeed, in next API level, the key store format may"]
#[doc = " changed at all. Only 8 bytes (simple DES) and 16 bytes (triple DES with 2"]
#[doc = " keys) are supported."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_des_key_s {
    #[doc = " key size"]
    pub size: cty::c_uchar,
    #[doc = " key value"]
    pub keys: [cty::c_uchar; 16usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        17usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_des_key_s>())).keys as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " Convenience type. See #cx_des_key_s."]
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    #[doc = " Initialize a DES Key."]
    #[doc = ""]
    #[doc = " Once initialized, the key may be stored in non-volatile memory"]
    #[doc = " an reused 'as-is' for any DES processing"]
    #[doc = ""]
    #[doc = " @param [in] rawkey"]
    #[doc = "   raw key value"]
    #[doc = ""]
    #[doc = " @param [in] key_len"]
    #[doc = "   key bytes lenght: 8,16 or 24"]
    #[doc = ""]
    #[doc = " @param [out] key"]
    #[doc = "   DES key to init"]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   ready to use key to init"]
    pub fn cx_des_init_key(
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_des_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Encrypt, Decrypt, Sign or Verify data with DES algorithm."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A des key fully inited with 'cx_des_init_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_LAST"]
    #[doc = "     - CX_ENCRYPT"]
    #[doc = "     - CX_DECRYPT"]
    #[doc = "     - CX_SIGN"]
    #[doc = "     - CX_VERIFY"]
    #[doc = "     - CX_PAD_NONE"]
    #[doc = "     - CX_PAD_ISO9797M1"]
    #[doc = "     - CX_PAD_ISO9797M2"]
    #[doc = "     - CX_CHAIN_ECB"]
    #[doc = "     - CX_CHAIN_CBC"]
    #[doc = "     - CX_CHAIN_CTR"]
    #[doc = ""]
    #[doc = " @param [in] in"]
    #[doc = "   Input data to encrypt/decrypt"]
    #[doc = ""]
    #[doc = " @param [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = "   If CX_LAST is set, padding is automatically done according to  'mode'."]
    #[doc = "   Else  'len' shall be a multiple of DES_BLOCK_SIZE."]
    #[doc = ""]
    #[doc = " @param [in] iv"]
    #[doc = "   Initial IV for chaining mode"]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   Either:"]
    #[doc = "     - encrypted/decrypted ouput data"]
    #[doc = "     - produced signature"]
    #[doc = "     - signature to check"]
    #[doc = ""]
    #[doc = " @param [in] out_len"]
    #[doc = "     size of output buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - In case of ENCRYPT, DECRYPT or SIGN mode: output lenght data"]
    #[doc = "   - In case of VERIFY mode: 0 if signature is false, DES_BLOCK_SIZE if"]
    #[doc = " signature is correct"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_des_iv(
        key: *const cx_des_key_t,
        mode: cty::c_int,
        iv: *mut cty::c_uchar,
        iv_len: cty::c_uint,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "  Same as cx_des_iv with initial IV assumed to be heigt zeros."]
    pub fn cx_des(
        key: *const cx_des_key_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " DES key container."]
#[doc = "  Such container should be initialize with cx_des_init_key to ensure future"]
#[doc = " API compatibility. Indeed, in next API level, the key store format may"]
#[doc = " changed at all. Only 16 bytes key (AES128) are supported ."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_aes_key_s {
    #[doc = " key size"]
    pub size: cty::c_uint,
    #[doc = " key value"]
    pub keys: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_aes_key_s>())).keys as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " Convenience type. See #cx_aes_key_s."]
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    #[doc = " Initialize a AES Key."]
    #[doc = " Once initialized, the key may be stored in non-volatile memory"]
    #[doc = " an reused 'as-is' for any AES processing"]
    #[doc = ""]
    #[doc = " @param [in] rawkey"]
    #[doc = "   raw key value"]
    #[doc = ""]
    #[doc = " @param [in] key_len"]
    #[doc = "   key bytes lenght: 8,16 or 24"]
    #[doc = ""]
    #[doc = " @param [out] key"]
    #[doc = "   AES key to init"]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   ready to use key to init"]
    pub fn cx_aes_init_key(
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_aes_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Encrypt, Decrypt, Sign or Verify data with AES algorithm."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A aes key fully inited with 'cx_aes_init_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_LAST"]
    #[doc = "     - CX_ENCRYPT"]
    #[doc = "     - CX_DECRYPT"]
    #[doc = "     - CX_SIGN"]
    #[doc = "     - CX_VERIFY"]
    #[doc = "     - CX_PAD_NONE"]
    #[doc = "     - CX_PAD_ISO9797M1"]
    #[doc = "     - CX_PAD_ISO9797M2"]
    #[doc = "     - CX_CHAIN_ECB"]
    #[doc = "     - CX_CHAIN_CBC"]
    #[doc = "     - CX_CHAIN_CTR"]
    #[doc = ""]
    #[doc = " @param [in] in"]
    #[doc = "   Input data to encrypt/decrypt"]
    #[doc = ""]
    #[doc = " @param [in] len"]
    #[doc = "   Length of input to data."]
    #[doc = "   If CX_LAST is set, padding is automtically done according to  'mode'."]
    #[doc = "   Else  'len' shall be a multiple of AES_BLOCK_SIZE."]
    #[doc = ""]
    #[doc = " @param [out] out"]
    #[doc = "   Either:"]
    #[doc = "     - encrypted/decrypted output data"]
    #[doc = "     - produced signature"]
    #[doc = "     - signature to check"]
    #[doc = ""]
    #[doc = " @param [in] out_len"]
    #[doc = "     size of output buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   - In case of ENCRYPT, DECRYPT or SIGN mode: output length data"]
    #[doc = "   - In case of VERIFY mode: 0 if signature is false, AES_BLOCK_SIZE if"]
    #[doc = " signature is correct"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_aes_iv(
        key: *const cx_aes_key_t,
        mode: cty::c_int,
        iv: *mut cty::c_uchar,
        iv_len: cty::c_uint,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "  Same as cx_aes_iv with initial IV assumed to be sixteen zeros."]
    pub fn cx_aes(
        key: *const cx_aes_key_t,
        mode: cty::c_int,
        in_: *const cty::c_uchar,
        in_len: cty::c_uint,
        out: *mut cty::c_uchar,
        out_len: cty::c_uint,
    ) -> cty::c_int;
}
#[doc = " Abstract RSA public key."]
#[doc = ""]
#[doc = " This type shall not be instantiate, it is only defined to allow unified API"]
#[doc = " for RSA operations"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_rsa_public_key_s {
    #[doc = " Key size in bytes"]
    pub size: cty::c_uint,
    #[doc = " 32 bits public exponent"]
    pub e: [cty::c_uchar; 4usize],
    #[doc = " public modulus"]
    pub n: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_rsa_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_rsa_private_key_s {
    #[doc = " Key size in bytes"]
    pub size: cty::c_uint,
    #[doc = " private exponent"]
    pub d: [cty::c_uchar; 1usize],
    #[doc = " public modulus"]
    pub n: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_private_key_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_rsa_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_private_key_s>())).n as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Convenience type. See #cx_rsa_public_key_s."]
pub type cx_rsa_public_key_t = cx_rsa_public_key_s;
#[doc = " Convenience type. See #cx_rsa_private_key_s."]
pub type cx_rsa_private_key_t = cx_rsa_private_key_s;
#[doc = " 1024 bits RSA public key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_1024_public_key_s {
    #[doc = " @copydoc cx_rsa_public_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_public_key_s::e"]
    pub e: [cty::c_uchar; 4usize],
    #[doc = " @copydoc cx_rsa_public_key_s::n"]
    pub n: [cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_1024_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_1024_public_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_rsa_1024_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_1024_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_1024_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " 1024 bits RSA private key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_1024_private_key_s {
    #[doc = " @copydoc cx_rsa_private_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_private_key_s::e"]
    pub d: [cty::c_uchar; 128usize],
    #[doc = " @copydoc cx_rsa_private_key_s::n"]
    pub n: [cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_1024_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_1024_private_key_s>(),
        260usize,
        concat!("Size of: ", stringify!(cx_rsa_1024_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_1024_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_1024_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_1024_private_key_s>())).n as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_1024_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Convenience type. See #cx_rsa_1024_public_key_s."]
pub type cx_rsa_1024_public_key_t = cx_rsa_1024_public_key_s;
#[doc = " Convenience type. See #cx_rsa_1024_private_key_s."]
pub type cx_rsa_1024_private_key_t = cx_rsa_1024_private_key_s;
#[doc = " 2048 bits RSA public key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_2048_public_key_s {
    #[doc = " @copydoc cx_rsa_public_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_public_key_s::e"]
    pub e: [cty::c_uchar; 4usize],
    #[doc = " @copydoc cx_rsa_public_key_s::n"]
    pub n: [cty::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_2048_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_2048_public_key_s>(),
        264usize,
        concat!("Size of: ", stringify!(cx_rsa_2048_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_2048_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_2048_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " 2048 bits RSA private key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_2048_private_key_s {
    #[doc = " @copydoc cx_rsa_private_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_private_key_s::e"]
    pub d: [cty::c_uchar; 256usize],
    #[doc = " @copydoc cx_rsa_private_key_s::n"]
    pub n: [cty::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_2048_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_2048_private_key_s>(),
        516usize,
        concat!("Size of: ", stringify!(cx_rsa_2048_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_2048_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_2048_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_2048_private_key_s>())).n as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_2048_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Convenience type. See #cx_rsa_2048_public_key_s."]
pub type cx_rsa_2048_public_key_t = cx_rsa_2048_public_key_s;
#[doc = " Convenience type. See #cx_rsa_2048_private_key_s."]
pub type cx_rsa_2048_private_key_t = cx_rsa_2048_private_key_s;
#[doc = " 3072 bits RSA public key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_3072_public_key_s {
    #[doc = " @copydoc cx_rsa_public_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_public_key_s::e"]
    pub e: [cty::c_uchar; 4usize],
    #[doc = " @copydoc cx_rsa_public_key_s::n"]
    pub n: [cty::c_uchar; 384usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_3072_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_3072_public_key_s>(),
        392usize,
        concat!("Size of: ", stringify!(cx_rsa_3072_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_3072_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_3072_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " 3072 bits RSA private key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_3072_private_key_s {
    #[doc = " @copydoc cx_rsa_private_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_private_key_s::e"]
    pub d: [cty::c_uchar; 384usize],
    #[doc = " @copydoc cx_rsa_private_key_s::n"]
    pub n: [cty::c_uchar; 384usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_3072_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_3072_private_key_s>(),
        772usize,
        concat!("Size of: ", stringify!(cx_rsa_3072_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_3072_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_3072_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_3072_private_key_s>())).n as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_3072_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Convenience type. See #cx_rsa_3072_public_key_s."]
pub type cx_rsa_3072_public_key_t = cx_rsa_3072_public_key_s;
#[doc = " Convenience type. See #cx_rsa_3072_private_key_s."]
pub type cx_rsa_3072_private_key_t = cx_rsa_3072_private_key_s;
#[doc = " 4096 bits RSA public key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_4096_public_key_s {
    #[doc = " @copydoc cx_rsa_public_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_public_key_s::e"]
    pub e: [cty::c_uchar; 4usize],
    #[doc = " @copydoc cx_rsa_public_key_s::n"]
    pub n: [cty::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_4096_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_4096_public_key_s>(),
        520usize,
        concat!("Size of: ", stringify!(cx_rsa_4096_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_4096_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_4096_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).e as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_public_key_s>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_public_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " 4096 bits RSA private key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_rsa_4096_private_key_s {
    #[doc = " @copydoc cx_rsa_private_key_s::size"]
    pub size: cty::c_uint,
    #[doc = " @copydoc cx_rsa_private_key_s::e"]
    pub d: [cty::c_uchar; 512usize],
    #[doc = " @copydoc cx_rsa_private_key_s::n"]
    pub n: [cty::c_uchar; 512usize],
}
#[test]
fn bindgen_test_layout_cx_rsa_4096_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_rsa_4096_private_key_s>(),
        1028usize,
        concat!("Size of: ", stringify!(cx_rsa_4096_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_rsa_4096_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_rsa_4096_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_rsa_4096_private_key_s>())).n as *const _ as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_rsa_4096_private_key_s),
            "::",
            stringify!(n)
        )
    );
}
#[doc = " Convenience type. See #cx_rsa_4096_public_key_s."]
pub type cx_rsa_4096_public_key_t = cx_rsa_4096_public_key_s;
#[doc = " Convenience type. See #cx_rsa_4096_private_key_s."]
pub type cx_rsa_4096_private_key_t = cx_rsa_4096_private_key_s;
extern "C" {
    #[doc = " Initialize a public RSA Key."]
    #[doc = ""]
    #[doc = " Once initialized, the key may be stored in non-volatile memory"]
    #[doc = " an reused 'as-is' for any RSA processing"]
    #[doc = ""]
    #[doc = " Passing NULL as raw key initializes the key without value. The key can not be"]
    #[doc = " used"]
    #[doc = ""]
    #[doc = " @param [in] 4 bytes public exponent"]
    #[doc = "   Raw key value or NULL."]
    #[doc = ""]
    #[doc = " @param [in] private modulus"]
    #[doc = "   Raw key as big endian  value or NULL."]
    #[doc = ""]
    #[doc = " @param [in] modulus_len"]
    #[doc = "   Key bytes lenght"]
    #[doc = ""]
    #[doc = " @param [out] key"]
    #[doc = "   Public RSA key to init."]
    #[doc = ""]
    #[doc = " @return something"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_init_public_key(
        exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        modulus: *const cty::c_uchar,
        modulus_len: cty::c_uint,
        key: *mut cx_rsa_public_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a private RSA Key."]
    #[doc = " Once initialized, the key may be stored in non-volatile memory"]
    #[doc = " an reused 'as-is' for any RSA processing"]
    #[doc = " Passing NULL as raw key initializes the key without value. The key can not be"]
    #[doc = " used"]
    #[doc = ""]
    #[doc = " @param [in] private exponent"]
    #[doc = "   Raw key value or NULL."]
    #[doc = ""]
    #[doc = " @param [in] private modulus"]
    #[doc = "   Raw key value or NULL."]
    #[doc = ""]
    #[doc = " @param [in] modulus_len"]
    #[doc = "   Key bytes lenght"]
    #[doc = ""]
    #[doc = " @param [out] key"]
    #[doc = "   Public RSA key to init."]
    #[doc = ""]
    #[doc = " @return something"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_init_private_key(
        exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        modulus: *const cty::c_uchar,
        modulus_len: cty::c_uint,
        key: *mut cx_rsa_private_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Generate a rsa key pair"]
    #[doc = ""]
    #[doc = " @param [in] modulus_len"]
    #[doc = "   Moduluse size in bytes. SHALL be one of 256,384 or 512"]
    #[doc = ""]
    #[doc = " @param [out] public_key"]
    #[doc = "   A rsa public key to generate. The real struct SHALL match the modulus_len"]
    #[doc = ""]
    #[doc = " @param [out] private_key"]
    #[doc = "   A rsa privat key to generate. The real struct SHALL match the modulus_len"]
    #[doc = ""]
    #[doc = " @param [in] pub_exponent"]
    #[doc = "   Public exponent. ZERO means default value: 0x010001 (65337). The public"]
    #[doc = " exponent shall be lesser than 0x0FFFFFFF. No verification is done on the"]
    #[doc = " public exponent value except its range. An invalid value may throw an error"]
    #[doc = " or provide unuseable key pair."]
    #[doc = ""]
    #[doc = " @param [in] externalPQ"]
    #[doc = "   If set to non NULL, it is assumed it contains primes  P and Q. They shall"]
    #[doc = " be modulus_len/2 bytes length and store in big endian order. P ="]
    #[doc = " externalPQ[0:modulus_len/2-1], Q = externalPQ[modulus_len/2 : modulus_len-1]"]
    #[doc = "   There is no verification on provided P and Q,  Invalid values may throw an"]
    #[doc = " error or provide unuseable key pair."]
    #[doc = ""]
    #[doc = " @return zero"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_generate_pair(
        modulus_len: cty::c_uint,
        public_key: *mut cx_rsa_public_key_t,
        private_key: *mut cx_rsa_private_key_t,
        pub_exponent: *const cty::c_uchar,
        exponent_len: cty::c_uint,
        externalPQ: *const cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Sign a hash message signature according to RSA specification."]
    #[doc = ""]
    #[doc = " When using PSS padding, the salt len is fixed to to hash output."]
    #[doc = " The MGF1 function is the one descrided in PKCS1 v2.0 specifiction, using the"]
    #[doc = " the same hash algorithm as specified by hashID."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A private RSA key fully inited with 'cx_rsa_init_private_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_PAD_PKCS1_1o5"]
    #[doc = "     - CX_PAD_PKCS1_PSS"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input hash. It shall be one of:"]
    #[doc = "    - CX_SHA224"]
    #[doc = "    - CX_SHA256"]
    #[doc = "    - CX_SHA384"]
    #[doc = "    - CX_SHA512"]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Input hash data to sign"]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] sig"]
    #[doc = "   Where to set the signature"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if signature is verified"]
    #[doc = "   0 is signarure is not verified"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_sign(
        key: *const cx_rsa_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Verify a hash message signature according to RSA specification."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A public RSA key fully inited with 'cx_rsa_init_public_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_PAD_PKCS1_1o5"]
    #[doc = "     - CX_PAD_PKCS1_PSS"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data.It shall be one of:"]
    #[doc = "    - CX_SHA224"]
    #[doc = "    - CX_SHA256"]
    #[doc = "    - CX_SHA384"]
    #[doc = "    - CX_SHA512"]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Input hash data to verify"]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] sig"]
    #[doc = "   RSA signature to verify encoded as raw bytes"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if signature is verified"]
    #[doc = "   0 is signarure is not verified"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_verify(
        key: *const cx_rsa_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Encrypt a message according to RSA specification."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A public RSA key fully inited with 'cx_rsa_init_public_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_PAD_PKCS1_1o5"]
    #[doc = "     - CX_PAD_PKCS1_OAEP"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier to use in OEAP padding. It shall be one of:"]
    #[doc = "    - CX_SHA224"]
    #[doc = "    - CX_SHA256"]
    #[doc = "    - CX_SHA384"]
    #[doc = "    - CX_SHA512"]
    #[doc = ""]
    #[doc = " @param [in] mesg"]
    #[doc = "   Input message data to encrypt"]
    #[doc = ""]
    #[doc = " @param [in] mesg_len"]
    #[doc = "   Length of input message"]
    #[doc = ""]
    #[doc = " @param [in] enc"]
    #[doc = "   Where to set the encrypted message"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if encryption succeed"]
    #[doc = "   0 else"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_encrypt(
        key: *const cx_rsa_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        mesg: *const cty::c_uchar,
        mesg_len: cty::c_uint,
        enc: *mut cty::c_uchar,
        enc_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Decrypt a mesg message signature according to RSA specification."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A private RSA key fully inited with 'cx_rsa_init_private_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_PAD_PKCS1_1o5"]
    #[doc = "     - CX_PAD_PKCS1_PSS"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier to use in OEAP padding. It shall be one of:"]
    #[doc = "    - CX_SHA224"]
    #[doc = "    - CX_SHA256"]
    #[doc = "    - CX_SHA384"]
    #[doc = "    - CX_SHA512"]
    #[doc = ""]
    #[doc = " @param [in] mesg"]
    #[doc = "   Input message to decrypt."]
    #[doc = ""]
    #[doc = " @param [in] mesg_len"]
    #[doc = "   Length of input  to decrypt."]
    #[doc = ""]
    #[doc = " @param [out] sig"]
    #[doc = "   Where tp put decrypted message"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   >=0 length of decrypted message"]
    #[doc = "   -1  if decryption fail"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_rsa_decrypt(
        key: *const cx_rsa_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        mesg: *const cty::c_uchar,
        mesg_len: cty::c_uint,
        dec: *mut cty::c_uchar,
        dec_len: cty::c_uint,
    ) -> cty::c_int;
}
pub const cx_curve_e_CX_CURVE_NONE: cx_curve_e = 0;
#[doc = " Low limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
#[doc = " Secp.org"]
pub const cx_curve_e_CX_CURVE_SECP256K1: cx_curve_e = 33;
#[doc = " Secp.org"]
pub const cx_curve_e_CX_CURVE_SECP256R1: cx_curve_e = 34;
pub const cx_curve_e_CX_CURVE_SECP384R1: cx_curve_e = 35;
pub const cx_curve_e_CX_CURVE_SECP521R1: cx_curve_e = 36;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256T1: cx_curve_e = 37;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256R1: cx_curve_e = 38;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320T1: cx_curve_e = 39;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320R1: cx_curve_e = 40;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384T1: cx_curve_e = 41;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384R1: cx_curve_e = 42;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512T1: cx_curve_e = 43;
#[doc = " BrainPool"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512R1: cx_curve_e = 44;
pub const cx_curve_e_CX_CURVE_FRP256V1: cx_curve_e = 45;
pub const cx_curve_e_CX_CURVE_Stark256: cx_curve_e = 46;
pub const cx_curve_e_CX_CURVE_BLS12_381_G1: cx_curve_e = 47;
#[doc = " High limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_END: cx_curve_e = 48;
#[doc = " Low limit (not included) of  Twister Edward curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARD_START: cx_curve_e = 64;
#[doc = " Ed25519 curve"]
pub const cx_curve_e_CX_CURVE_Ed25519: cx_curve_e = 65;
#[doc = " Ed25519 curve"]
pub const cx_curve_e_CX_CURVE_Ed448: cx_curve_e = 66;
#[doc = " Ed25519 curve"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARD_END: cx_curve_e = 67;
#[doc = " Low limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_START: cx_curve_e = 96;
#[doc = " Curve25519 curve"]
pub const cx_curve_e_CX_CURVE_Curve25519: cx_curve_e = 97;
#[doc = " Curve25519 curve"]
pub const cx_curve_e_CX_CURVE_Curve448: cx_curve_e = 98;
#[doc = " Curve25519 curve"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_END: cx_curve_e = 99;
#[doc = " List of supported elliptic curves"]
pub type cx_curve_e = cty::c_uint;
#[doc = " Convenience type. See #cx_curve_e."]
pub use self::cx_curve_e as cx_curve_t;
#[doc = " Weirstrass curve :     y^3=x^2+a*x+b        over F(p)"]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub p: *mut cty::c_uchar,
    pub Hp: *mut cty::c_uchar,
    pub Gx: *mut cty::c_uchar,
    pub Gy: *mut cty::c_uchar,
    pub n: *mut cty::c_uchar,
    pub Hn: *mut cty::c_uchar,
    pub h: cty::c_int,
    #[doc = "  a coef"]
    pub a: *mut cty::c_uchar,
    #[doc = "  b coef"]
    pub b: *mut cty::c_uchar,
}
#[test]
fn bindgen_test_layout_cx_curve_weierstrass_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_weierstrass_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_weierstrass_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).bit_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).p as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Hp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Gx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Gy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).n as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).Hn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).a as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_weierstrass_s>())).b as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(b)
        )
    );
}
#[doc = " Convenience type. See #cx_curve_weierstrass_s."]
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_twisted_edward_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub p: *mut cty::c_uchar,
    pub Hp: *mut cty::c_uchar,
    pub Gx: *mut cty::c_uchar,
    pub Gy: *mut cty::c_uchar,
    pub n: *mut cty::c_uchar,
    pub Hn: *mut cty::c_uchar,
    pub h: cty::c_int,
    #[doc = "  a coef"]
    pub a: *mut cty::c_uchar,
    #[doc = "  d coef"]
    pub d: *mut cty::c_uchar,
    #[doc = " @internal Square root of -1 or zero"]
    pub I: *mut cty::c_uchar,
    #[doc = " @internal  (q+3)/8 or (q+1)/4"]
    pub Qq: *mut cty::c_uchar,
}
#[test]
fn bindgen_test_layout_cx_curve_twisted_edward_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_twisted_edward_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_curve_twisted_edward_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_twisted_edward_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_twisted_edward_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).bit_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).length as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).p as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).Hp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(Hp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).Gx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).Gy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).n as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).Hn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).a as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).d as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).I as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(I)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_twisted_edward_s>())).Qq as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edward_s),
            "::",
            stringify!(Qq)
        )
    );
}
#[doc = " Convenience type. See #cx_curve_twisted_edward_s."]
pub type cx_curve_twisted_edward_t = cx_curve_twisted_edward_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub p: *mut cty::c_uchar,
    pub Hp: *mut cty::c_uchar,
    pub Gx: *mut cty::c_uchar,
    pub Gy: *mut cty::c_uchar,
    pub n: *mut cty::c_uchar,
    pub Hn: *mut cty::c_uchar,
    pub h: cty::c_int,
    #[doc = "  a coef"]
    pub a: *mut cty::c_uchar,
    #[doc = "  b coef"]
    pub b: *mut cty::c_uchar,
    #[doc = " @internal (a + 2) / 4"]
    pub A24: *mut cty::c_uchar,
    #[doc = " @internal  (p-1)/2"]
    pub P1: *mut cty::c_uchar,
}
#[test]
fn bindgen_test_layout_cx_curve_montgomery_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_montgomery_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_montgomery_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).bit_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).p as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Hp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Gx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Gy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).n as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).Hn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).a as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).b as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).A24 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(A24)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_montgomery_s>())).P1 as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(P1)
        )
    );
}
#[doc = " Convenience type. See #cx_curve_montgomery_s."]
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[doc = " Abstract type for elliptic curve domain"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub p: *mut cty::c_uchar,
    pub Hp: *mut cty::c_uchar,
    pub Gx: *mut cty::c_uchar,
    pub Gy: *mut cty::c_uchar,
    pub n: *mut cty::c_uchar,
    pub Hn: *mut cty::c_uchar,
    pub h: cty::c_int,
}
#[test]
fn bindgen_test_layout_cx_curve_domain_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_curve_domain_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_domain_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).bit_size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).p as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Hp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Gx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Gy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).n as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).Hn as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_curve_domain_s>())).h as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(h)
        )
    );
}
#[doc = " Convenience type. See #cx_curve_domain_s."]
pub type cx_curve_domain_t = cx_curve_domain_s;
extern "C" {
    #[doc = " Retrieve domain parameters"]
    #[doc = ""]
    #[doc = " @param curve curve ID #cx_curve_e"]
    #[doc = ""]
    #[doc = " @return curve parameters"]
    pub fn cx_ecfp_get_domain(curve: cx_curve_t) -> *const cx_curve_domain_t;
}
#[doc = " Public Elliptic Curve key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub W_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub W: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
#[doc = " Private Elliptic Curve key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_private_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).d_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
pub type __cx_ecfp_private_key_t = cx_ecfp_private_key_s;
pub type __cx_ecfp_public_key_t = cx_ecfp_public_key_s;
#[doc = " Up to 256 bits Public Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub W_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub W: [cty::c_uchar; 65usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_public_key_s>(),
        76usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
#[doc = " Up to 256 bits Private Elliptic Curve key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_private_key_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_256_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Up to 256 bits Extended Private Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_extended_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_extended_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_extended_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_extended_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_256_extended_private_key_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).curve as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).d_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_256_extended_private_key_s>())).d as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Convenience type. See #cx_ecfp_256_public_key_s."]
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " temporary def type. See #cx_ecfp_256_private_key_s."]
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Convenience type. See #cx_ecfp_256_extended_private_key_s."]
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 384 bits Public Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub W_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub W: [cty::c_uchar; 97usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_public_key_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
#[doc = " Up to 384 bits Private Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 48usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_private_key_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_384_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Convenience type. See #cx_ecfp_384_public_key_s."]
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
#[doc = " Convenience type. See #cx_ecfp_384_private_key_s."]
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[doc = " Up to 512 bits Public Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub W_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub W: [cty::c_uchar; 129usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_public_key_s>(),
        140usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
#[doc = " Up to 512 bits Private Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_512_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Up to 512 bits Extended Private Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 128usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_extented_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_extented_private_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_extented_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_extented_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_512_extented_private_key_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).curve as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).d_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_512_extented_private_key_s>())).d as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Convenience type. See #cx_ecfp_512_public_key_s."]
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
#[doc = " Convenience type. See #cx_ecfp_512_private_key_s."]
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
#[doc = " Convenience type. See #cx_ecfp_512_extented_private_key_s."]
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[doc = " Up to 640 bits Public Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub W_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub W: [cty::c_uchar; 161usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_public_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_public_key_s>(),
        172usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).curve as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).W_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_public_key_s>())).W as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
#[doc = " Up to 640 bits Private Elliptic Curve key"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    #[doc = " curve ID #cx_curve_e"]
    pub curve: cx_curve_t,
    #[doc = " Public key length in bytes"]
    pub d_len: cty::c_uint,
    #[doc = " Public key value starting at offset 0"]
    pub d: [cty::c_uchar; 80usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_private_key_s() {
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_private_key_s>(),
        88usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).curve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).d_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cx_ecfp_640_private_key_s>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
#[doc = " Convenience type. See #cx_ecfp_640_public_key_s."]
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
#[doc = " Convenience type. See #cx_ecfp_640_private_key_s."]
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    #[doc = " Verify that a given point is really on the specified curve."]
    #[doc = ""]
    #[doc = " @param [in] domain"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [in]  P"]
    #[doc = "   The point to test  encoded as: 04 x y"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    1 if point is on the curve"]
    #[doc = "    0 if point is not on the curve"]
    #[doc = "   -1 if undefined (function not impl)"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_is_valid_point(
        curve: cx_curve_t,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Verify that a given point is really on the specified curve and its order"]
    #[doc = " is the curve order"]
    #[doc = ""]
    #[doc = " @param [in] domain"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [in]  public_point"]
    #[doc = "   The point to test  encoded as: 04 x y"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "    1 if point is on the curve"]
    #[doc = "    0 if point is not on the curve"]
    #[doc = "   -1 if undefined (function not impl)"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_is_cryptographic_point(
        curve: cx_curve_t,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Add two affine point"]
    #[doc = ""]
    #[doc = " This routine only support Weierstrass and Twisted edward curve."]
    #[doc = ""]
    #[doc = " @param [in] domain"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [out] R"]
    #[doc = "   P+Q encoded as: 04 x y, where x and y are"]
    #[doc = "   encoded as  big endian raw value and have bits length equals to"]
    #[doc = "   the curve size."]
    #[doc = ""]
    #[doc = " @param [in] P"]
    #[doc = "   First point to add *"]
    #[doc = "   The value shall be a point encoded as: 04 x y, where x and y are"]
    #[doc = "   encoded as  big endian raw value and have bits length equals to"]
    #[doc = "   the curve size."]
    #[doc = ""]
    #[doc = " @param [in] Q"]
    #[doc = "   Second point to add"]
    #[doc = ""]
    #[doc = " @param [in]  public_point"]
    #[doc = "   The point to test  encoded as: 04 x y"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   R encoding length, if add success"]
    #[doc = "   0 if result is infinity"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_add_point(
        curve: cx_curve_t,
        R: *mut cty::c_uchar,
        P: *const cty::c_uchar,
        Q: *const cty::c_uchar,
        X_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Multiply an affine point"]
    #[doc = ""]
    #[doc = " @param [in] domain"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [out] R"]
    #[doc = "   R = k.P encoded as: 04 x y, where x and y are"]
    #[doc = "   encoded as  big endian raw value and have bits length equals to"]
    #[doc = "   the curve size."]
    #[doc = ""]
    #[doc = " @param [in] P"]
    #[doc = "   Point to multiply *"]
    #[doc = "   The value shall be a point encoded as: 04 x y, where x and y are"]
    #[doc = "   encoded as  big endian raw value and have bits length equals to"]
    #[doc = "   the curve size."]
    #[doc = ""]
    #[doc = " @param [in] k"]
    #[doc = "   scalar to multiply, encoded as big endian integer"]
    #[doc = ""]
    #[doc = " @param [in] k_len"]
    #[doc = "   byte length of scalar to multiply"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   R encoding length, if mult success"]
    #[doc = "   0 if result is infinity"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_scalar_mult(
        curve: cx_curve_t,
        P: *mut cty::c_uchar,
        P_len: cty::c_uint,
        k: *const cty::c_uchar,
        k_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a public ECFP Key."]
    #[doc = " Once initialized, the key may be stored in non-volatile memory"]
    #[doc = " an reused 'as-is' for any ECDSA/25519 processing"]
    #[doc = " Passing NULL as raw key initializes the key without value. The key may be"]
    #[doc = "used"]
    #[doc = " as parameter for cx_ecfp_generate_pair."]
    #[doc = ""]
    #[doc = " @param [in] curve"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [in] rawkey"]
    #[doc = "   Raw key value or NULL."]
    #[doc = "   The value shall be the public point encoded as:"]
    #[doc = "     - '04 x y' for Weiertrass curve"]
    #[doc = "     - '04 x y'  or '02 y' (plus sign) for twisted Edward curves"]
    #[doc = "     - '04 x y'  or '02 x' for Montgomery curves"]
    #[doc = "    where x and y are encoded as big endian raw value and have bits length"]
    #[doc = "    equals to the curve size. Any specific integer decoding from binary,"]
    #[doc = "    such as specified in RFC7748 and RFC eddsa-draft, is up to caller."]
    #[doc = ""]
    #[doc = " @param [in] key_len"]
    #[doc = "   Key bytes lenght"]
    #[doc = ""]
    #[doc = " @param [out] key"]
    #[doc = "   Public ecfp key to init."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   Ready to use key to init"]
    #[doc = ""]
    #[doc = " @return something"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_init_public_key(
        curve: cx_curve_t,
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        key: *mut cx_ecfp_public_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Initialize a private ECFP Key."]
    #[doc = " Once initialized, the key may be  stored in non-volatile memory"]
    #[doc = " and reused 'as-is' for any ECDSA/EC25519 processing"]
    #[doc = " Passing NULL as raw key initializes the key without value. The key may be"]
    #[doc = " used as parameter for cx_ecfp_generate_pair."]
    #[doc = ""]
    #[doc = " @param [in] curve"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [in] rawkey"]
    #[doc = "   Raw key value or NULL."]
    #[doc = "   The value shall be the private key big endian raw value."]
    #[doc = ""]
    #[doc = " @param [in] key_len"]
    #[doc = "   Key bytes lenght"]
    #[doc = ""]
    #[doc = " @param [out] pvkey"]
    #[doc = "   Private ecfp key to init."]
    #[doc = ""]
    #[doc = " @param key"]
    #[doc = "   Ready to use key to init"]
    #[doc = ""]
    #[doc = " @return something"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_init_private_key(
        curve: cx_curve_t,
        rawkey: *const cty::c_uchar,
        key_len: cty::c_uint,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Generate a ecfp key pair."]
    #[doc = " This function call cx_ecfp_generate_pair2 with hashID equals to CX_SHA512."]
    #[doc = ""]
    #[doc = " @param [in] curve"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [out] pubkey"]
    #[doc = "   A public ecfp public key to generate."]
    #[doc = ""]
    #[doc = " @param [in,out] privkey"]
    #[doc = "   A private ecfp private key to generate."]
    #[doc = "   Either:"]
    #[doc = "     - if the private ecfp key is fully inited, i.e  parameter 'rawkey' of"]
    #[doc = "       'cx_ecfp_init_private_key' is NOT null, the private key value is kept"]
    #[doc = "       if the 'keep_private' parameter is non zero"]
    #[doc = "     - else a new private key is generated."]
    #[doc = ""]
    #[doc = " @param [in] keepprivate if set to non zero, keep the private key value if"]
    #[doc = " set. Else generate a new random one"]
    #[doc = ""]
    #[doc = " @return zero"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_generate_pair(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Generate a ecfp key pair"]
    #[doc = ""]
    #[doc = " @param [in] curve"]
    #[doc = "   The curve domain parameters to work with."]
    #[doc = ""]
    #[doc = " @param [out] pubkey"]
    #[doc = "   A public ecfp public key to generate."]
    #[doc = ""]
    #[doc = " @param [in,out] privkey"]
    #[doc = "   A private ecfp private key to generate."]
    #[doc = "   Either:"]
    #[doc = "     - if the private ecfp key is fully inited, i.e  parameter 'rawkey' of"]
    #[doc = "       'cx_ecfp_init_private_key' is NOT null, the private key value is kept"]
    #[doc = "       if the 'keep_private' parameter is non zero"]
    #[doc = "     - else a new private key is generated."]
    #[doc = ""]
    #[doc = " @param [in] keepprivate if set to non zero, keep the private key value if"]
    #[doc = " set. Else generate a new random one"]
    #[doc = ""]
    #[doc = "  @param [in] hashID Hash to use for eddsa (SHA512, SHA3 and Keccak are"]
    #[doc = " supported)"]
    #[doc = ""]
    #[doc = " @return zero"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecfp_generate_pair2(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: cty::c_int,
        hashID: cx_md_t,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Sign a hash message according to ECDSA specification."]
    #[doc = ""]
    #[doc = " @param [in] pvkey"]
    #[doc = "   A private ecfp key fully inited with 'cx_ecfp_init_private_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_RND_TRNG"]
    #[doc = "     - CX_RND_RFC6979"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data."]
    #[doc = "  This parameter is mandatory for rng of type CX_RND_RFC6979."]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Input data to sign."]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = "   The data length must be lesser than the curve size."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] sig"]
    #[doc = "   ECDSA signature encoded as TLV:  30 L 02 Lr r 02 Ls s"]
    #[doc = ""]
    #[doc = " @param [out] info"]
    #[doc = "   Set CX_ECCINFO_PARITY_ODD if Y is odd when computing k.G"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Full length of signature"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecdsa_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Verify a hash message signature according to ECDSA specification."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A public ecfp key fully inited with 'cx_ecfp_init_public_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_LAST"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data."]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Signed input data to verify the signature."]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = "   The data length must be lesser than the curve size."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] sig"]
    #[doc = "   ECDSA signature to verify encoded as TLV:  30 L 02 Lr r 02 Ls s"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if signature is verified"]
    #[doc = "   0 is signarure is not verified"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecdsa_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Sign a hash message according to ECSchnorr specification (BSI TR 03111)."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A private ecfp key fully inited with 'cx_ecfp_init_private_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_ECSCHNORR_XY"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data."]
    #[doc = "  This parameter is mandatory for rng of type CX_RND_RFC6979."]
    #[doc = ""]
    #[doc = " @param [in] msg"]
    #[doc = "   Input data to sign."]
    #[doc = ""]
    #[doc = " @param [in] msg_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [out] sig"]
    #[doc = "   ECSchnorr signature encoded as TLV:  30 L 02 Lr r 02 Ls s"]
    #[doc = ""]
    #[doc = " @param [out] info"]
    #[doc = "   Set to zero"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Full length of signature"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecschnorr_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        msg: *const cty::c_uchar,
        msg_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Verify a hash message signature according to ECSchnorr specification (BSI TR"]
    #[doc = " 03111)."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A public ecfp key fully inited with 'cx_ecfp_init_public_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_ECSCHNORR_XY"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data."]
    #[doc = ""]
    #[doc = " @param [in] msg"]
    #[doc = "   Signed input data to verify the signature."]
    #[doc = ""]
    #[doc = " @param [in] msg_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] sig"]
    #[doc = "   ECDSA signature to verify encoded as TLV:  30 L 02 Lr r 02 Ls s"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if signature is verified"]
    #[doc = "   0 is signature is not verified"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecschnorr_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        msg: *const cty::c_uchar,
        msg_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = "  Compress point according to RFC8032."]
    #[doc = ""]
    #[doc = " @param [in]     domain"]
    #[doc = " @param [in,out] P"]
    pub fn cx_edward_compress_point(curve: cx_curve_t, P: *mut cty::c_uchar, P_len: cty::c_uint);
}
extern "C" {
    #[doc = "  Decompress point according to draft-irtf-cfrg-eddsa-05."]
    #[doc = ""]
    #[doc = " @param [in]     domain"]
    #[doc = " @param [in,out] P"]
    pub fn cx_edward_decompress_point(curve: cx_curve_t, P: *mut cty::c_uchar, P_len: cty::c_uint);
}
extern "C" {
    #[doc = "  Retrieve (a,h) = (Kr, Kl), such (Kr, Kl) = Hash(pv_key) as specified in"]
    #[doc = " RFC8032"]
    #[doc = ""]
    #[doc = " @param [in] pv_key"]
    #[doc = "   A private ecfp key fully inited with 'cx_ecfp_init_private_key'."]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data. SHA512, SHA3 and Keccak are"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param [out] pu_key"]
    #[doc = "   A public null-inited ecfp key container for retrieving public key A."]
    #[doc = ""]
    #[doc = " @param [out] a"]
    #[doc = "   private scalar such A = a.B"]
    #[doc = ""]
    #[doc = " @param [out] h"]
    #[doc = "   prefix signature"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data. SHA512, SHA3 and Keccak are"]
    #[doc = " supported."]
    #[doc = ""]
    pub fn cx_eddsa_get_public_key(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut cty::c_uchar,
        a_len: cty::c_uint,
        h: *mut cty::c_uchar,
        h_len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Sign a hash message according to EdDSA specification RFC8032."]
    #[doc = ""]
    #[doc = " @param [in] pv_key"]
    #[doc = "   A private ecfp key fully inited with 'cx_ecfp_init_private_key'."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "      <none>"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data. SHA512, SHA3 and Keccak are"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Input data to sign."]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = "   The data length must be lesser than the curve size."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = "   UNUSED, SHALL BE NULL"]
    #[doc = ""]
    #[doc = " @param [in] ctx_len"]
    #[doc = "   UNUSED, SHALL BE ZERO"]
    #[doc = ""]
    #[doc = " @param [out] sig"]
    #[doc = "   EdDSA signature encoded as : R|S"]
    #[doc = ""]
    #[doc = " @param [out] info"]
    #[doc = "   Set to zero"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   Full length of signature"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_eddsa_sign(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        ctx: *const cty::c_uchar,
        ctx_len: cty::c_uint,
        sig: *mut cty::c_uchar,
        sig_len: cty::c_uint,
        info: *mut cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Verify a hash message signature according to EDDSA specification RFC8032."]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A public ecfp key fully inited with 'cx_ecfp_init_public_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - <none>"]
    #[doc = ""]
    #[doc = " @param [in] hashID"]
    #[doc = "  Hash identifier used to compute the input data.  SHA512, SHA3 and Keccak are"]
    #[doc = " supported."]
    #[doc = ""]
    #[doc = " @param [in] hash"]
    #[doc = "   Signed input data to verify the signature."]
    #[doc = "   The data should be the hash of the original message."]
    #[doc = "   The data length must be lesser than the curve size."]
    #[doc = ""]
    #[doc = " @param [in] hash_len"]
    #[doc = "   Length of input to data."]
    #[doc = ""]
    #[doc = " @param [in] ctx"]
    #[doc = "   UNUSED, SHALL BE NULL"]
    #[doc = ""]
    #[doc = " @param [in] ctx_len"]
    #[doc = "   UNUSED, SHALL BE ZERO"]
    #[doc = ""]
    #[doc = " @param [in] sig"]
    #[doc = "   EDDSA signature to verify encoded as : R|S"]
    #[doc = ""]
    #[doc = " @param [in] sig_len"]
    #[doc = "   sig length in bytes"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "   1 if signature is verified"]
    #[doc = "   0 is signarure is not verified"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_eddsa_verify(
        pukey: *const cx_ecfp_public_key_t,
        mode: cty::c_int,
        hashID: cx_md_t,
        hash: *const cty::c_uchar,
        hash_len: cty::c_uint,
        ctx: *const cty::c_uchar,
        ctx_len: cty::c_uint,
        sig: *const cty::c_uchar,
        sig_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compute a shared secret according to ECDH specifiaction"]
    #[doc = " Depending on the mode, the shared secret is either the full point or"]
    #[doc = " only the x coordinate"]
    #[doc = ""]
    #[doc = " @param [in] key"]
    #[doc = "   A private ecfp key fully inited with 'cx_ecfp_init_private_key'"]
    #[doc = ""]
    #[doc = " @param [in] mode"]
    #[doc = "   Crypto mode flags. See above."]
    #[doc = "   Supported flags:"]
    #[doc = "     - CX_ECDH_POINT"]
    #[doc = "     - CX_ECDH_X"]
    #[doc = ""]
    #[doc = " @param [in] P"]
    #[doc = "   Other party public point encoded as: 04 x y, where x and y are"]
    #[doc = "   encoded as big endian raw value and have bits length equals to"]
    #[doc = "   the curve size."]
    #[doc = ""]
    #[doc = " @param [out] secret"]
    #[doc = "   Generated shared secret."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return size of secret"]
    #[doc = ""]
    #[doc = " @throws INVALID_PARAMETER"]
    pub fn cx_ecdh(
        pvkey: *const cx_ecfp_private_key_t,
        mode: cty::c_int,
        P: *const cty::c_uchar,
        P_len: cty::c_uint,
        secret: *mut cty::c_uchar,
        secret_len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compute a 16 bits checksum value."]
    #[doc = " The 16 bits value is computed according to the CRC16 CCITT definition."]
    #[doc = ""]
    #[doc = " @param [in] buffer"]
    #[doc = "   The buffer to compute the crc over."]
    #[doc = ""]
    #[doc = " @param [in]"]
    #[doc = "   Bytes Length of the 'buffer'"]
    #[doc = ""]
    #[doc = " @return current crc value"]
    #[doc = ""]
    pub fn cx_crc16(buffer: *const cty::c_void, len: size_t) -> cty::c_ushort;
}
extern "C" {
    #[doc = " Accumulate more data to crc"]
    pub fn cx_crc16_update(
        crc: cty::c_ushort,
        buffer: *const cty::c_void,
        len: size_t,
    ) -> cty::c_ushort;
}
extern "C" {
    #[doc = " Compare to unsigned long big-endian integer"]
    #[doc = " The maximum length supported is 64."]
    #[doc = ""]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param len  byte length of a, b"]
    #[doc = ""]
    #[doc = " @return 0 if a==b,  negative value if a<b, positive value if a>b"]
    pub fn cx_math_cmp(
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Compare to unsigned long big-endian integer to zero"]
    #[doc = ""]
    #[doc = " @param a    value to compare to zero"]
    #[doc = " @param len  byte length of a"]
    #[doc = ""]
    #[doc = " @return 1 if a==0,  0 else"]
    pub fn cx_math_is_zero(a: *const cty::c_uchar, len: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Addition of two big integer: r = a+b"]
    #[doc = ""]
    #[doc = " @param r    where to put result"]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param m    modulo"]
    #[doc = " @param len  byte length of r, a, b, m"]
    #[doc = ""]
    #[doc = " @return carry"]
    pub fn cx_math_add(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Subtraction of two big integer: r = a-b"]
    #[doc = ""]
    #[doc = " @param r    where to put result"]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param m    modulo"]
    #[doc = " @param len  byte length of r, a, b, m"]
    #[doc = ""]
    #[doc = " @return borrow"]
    pub fn cx_math_sub(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    ) -> cty::c_int;
}
extern "C" {
    #[doc = " Subtraction of two big integer: r = a-b"]
    #[doc = ""]
    #[doc = " @param r    where to put result, len*2 bytes"]
    #[doc = " @param a    first operand, len bytes"]
    #[doc = " @param b    second operand, len bytes"]
    #[doc = " @param len  byte length base of a, b, r"]
    #[doc = ""]
    pub fn cx_math_mult(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular addition of two big integer: r = a+b mod m"]
    #[doc = ""]
    #[doc = " @param r    where to put result"]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param m    modulo"]
    #[doc = " @param len  byte length of r, a, b, m"]
    #[doc = ""]
    pub fn cx_math_addm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular subtraction of tow big integer: r = a-b mod m"]
    #[doc = ""]
    #[doc = " @param r    where to put result"]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param m    modulo"]
    #[doc = " @param len  byte length of r, a, b, m"]
    #[doc = ""]
    pub fn cx_math_subm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular multiplication of tow big integer: r = a*b mod m"]
    #[doc = ""]
    #[doc = " @param r    where to put result"]
    #[doc = " @param a    first operand"]
    #[doc = " @param b    second operand"]
    #[doc = " @param m    modulo"]
    #[doc = " @param len  byte length of r, a, b, m"]
    #[doc = ""]
    pub fn cx_math_multm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        b: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular exponentiation of tow big integer: r = a^^e mod m"]
    #[doc = ""]
    #[doc = " @param r     where to put result"]
    #[doc = " @param a     first operand"]
    #[doc = " @param e     second operand"]
    #[doc = " @param len_e byte length of e"]
    #[doc = " @param m     modulo"]
    #[doc = " @param len   byte length of r, a, b, m"]
    #[doc = ""]
    pub fn cx_math_powm(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        e: *const cty::c_uchar,
        len_e: cty::c_uint,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Reduce in place (left zero padded) the given value: v = v mod m"]
    #[doc = ""]
    #[doc = " @param v        value to reduce"]
    #[doc = " @param len_v    shall be >= len_m"]
    #[doc = " @param m        modulus"]
    #[doc = " @param len_m    length of modulus"]
    #[doc = ""]
    pub fn cx_math_modm(
        v: *mut cty::c_uchar,
        len_v: cty::c_uint,
        m: *const cty::c_uchar,
        len_m: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular prime inversion: r = (a^-1) mod m, with m prime"]
    #[doc = ""]
    #[doc = " @param r     where to put result"]
    #[doc = " @param a        value to invert"]
    #[doc = " @param m        modulus"]
    #[doc = " @param len   length of r,a,m"]
    #[doc = ""]
    pub fn cx_math_invprimem(
        r: *mut cty::c_uchar,
        a: *const cty::c_uchar,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Modular integer inversion: r = (a^-1) mod m, with a 32 bits"]
    #[doc = ""]
    #[doc = " @param r     where to put result"]
    #[doc = " @param a     value to invert"]
    #[doc = " @param m     modulus"]
    #[doc = " @param len   length of r,m"]
    #[doc = ""]
    pub fn cx_math_invintm(
        r: *mut cty::c_uchar,
        a: cty::c_ulong,
        m: *const cty::c_uchar,
        len: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Test if p is prime"]
    #[doc = ""]
    #[doc = " @param p     value to test"]
    #[doc = " @param len   length p"]
    pub fn cx_math_is_prime(p: *const cty::c_uchar, len: cty::c_uint) -> cty::c_int;
}
extern "C" {
    #[doc = " Find in place the next prime number follwing n"]
    #[doc = ""]
    #[doc = " @param n     seed value for next prime"]
    #[doc = " @param len   length n"]
    pub fn cx_math_next_prime(n: *mut cty::c_uchar, len: cty::c_uint);
}
extern "C" {
    #[doc = " @internal"]
    #[doc = "  @private"]
    pub fn cx_selftest() -> cty::c_int;
}
pub const bolos_ux_e_BOLOS_UX_INITIALIZE: bolos_ux_e = 0;
pub const bolos_ux_e_BOLOS_UX_EVENT: bolos_ux_e = 1;
pub const bolos_ux_e_BOLOS_UX_KEYBOARD: bolos_ux_e = 2;
pub const bolos_ux_e_BOLOS_UX_WAKE_UP: bolos_ux_e = 3;
pub const bolos_ux_e_BOLOS_UX_STATUS_BAR: bolos_ux_e = 4;
pub const bolos_ux_e_BOLOS_UX_BOOT: bolos_ux_e = 5;
pub const bolos_ux_e_BOLOS_UX_BOOT_NOT_PERSONALIZED: bolos_ux_e = 6;
pub const bolos_ux_e_BOLOS_UX_BOOT_ONBOARDING: bolos_ux_e = 7;
pub const bolos_ux_e_BOLOS_UX_BOOT_UNSAFE_WIPE: bolos_ux_e = 8;
pub const bolos_ux_e_BOLOS_UX_BOOT_UX_NOT_SIGNED: bolos_ux_e = 9;
pub const bolos_ux_e_BOLOS_UX_BOLOS_START: bolos_ux_e = 10;
pub const bolos_ux_e_BOLOS_UX_DASHBOARD: bolos_ux_e = 11;
pub const bolos_ux_e_BOLOS_UX_PROCESSING: bolos_ux_e = 12;
pub const bolos_ux_e_BOLOS_UX_LOADER: bolos_ux_e = 13;
pub const bolos_ux_e_BOLOS_UX_VALIDATE_PIN: bolos_ux_e = 14;
pub const bolos_ux_e_BOLOS_UX_CONSENT_UPGRADE: bolos_ux_e = 15;
pub const bolos_ux_e_BOLOS_UX_CONSENT_APP_ADD: bolos_ux_e = 16;
pub const bolos_ux_e_BOLOS_UX_CONSENT_APP_DEL: bolos_ux_e = 17;
pub const bolos_ux_e_BOLOS_UX_CONSENT_APP_UPG: bolos_ux_e = 18;
pub const bolos_ux_e_BOLOS_UX_CONSENT_ISSUER_KEY: bolos_ux_e = 19;
pub const bolos_ux_e_BOLOS_UX_CONSENT_CUSTOMCA_KEY: bolos_ux_e = 20;
pub const bolos_ux_e_BOLOS_UX_CONSENT_FOREIGN_KEY: bolos_ux_e = 21;
pub const bolos_ux_e_BOLOS_UX_CONSENT_GET_DEVICE_NAME: bolos_ux_e = 22;
pub const bolos_ux_e_BOLOS_UX_CONSENT_SET_DEVICE_NAME: bolos_ux_e = 23;
pub const bolos_ux_e_BOLOS_UX_CONSENT_RESET_CUSTOMCA_KEY: bolos_ux_e = 24;
pub const bolos_ux_e_BOLOS_UX_CONSENT_SETUP_CUSTOMCA_KEY: bolos_ux_e = 25;
pub const bolos_ux_e_BOLOS_UX_APP_ACTIVITY: bolos_ux_e = 26;
pub const bolos_ux_e_BOLOS_UX_CONSENT_NOT_INTERACTIVE_ONBOARD: bolos_ux_e = 27;
pub const bolos_ux_e_BOLOS_UX_PREPARE_RUN_APP: bolos_ux_e = 28;
pub const bolos_ux_e_BOLOS_UX_MCU_UPGRADE_REQUIRED: bolos_ux_e = 29;
pub const bolos_ux_e_BOLOS_UX_CONSENT_RUN_APP: bolos_ux_e = 30;
pub const bolos_ux_e_BOLOS_UX_SECURITY_BOOT_DELAY: bolos_ux_e = 31;
pub const bolos_ux_e_DEPRECATED_BOLOS_UX_CONSENT_GENUINENESS: bolos_ux_e = 32;
pub const bolos_ux_e_BOLOS_UX_BOOT_MENU: bolos_ux_e = 33;
pub const bolos_ux_e_BOLOS_UX_CONTROL_CENTER: bolos_ux_e = 34;
pub const bolos_ux_e_BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST: bolos_ux_e = 35;
pub const bolos_ux_e_BOLOS_UX_ASYNCHMODAL_PAIRING_CANCEL: bolos_ux_e = 36;
pub const bolos_ux_e_BOLOS_UX_CONSENT_LISTAPPS: bolos_ux_e = 37;
pub const bolos_ux_e_BOLOS_UX_LAST_ID: bolos_ux_e = 38;
#[doc = "BOLOS RAM LAYOUT"]
#[doc = "msp                          psp                   psp"]
#[doc = "| bolos ram <-os stack-| bolos ux ram <-ux_stack-| app ram <-app stack-|"]
#[doc = ""]
#[doc = "ux and app are seen as applications."]
#[doc = "os is not an application (it calls ux upon user inputs)"]
pub type bolos_ux_e = cty::c_uint;
#[doc = "BOLOS RAM LAYOUT"]
#[doc = "msp                          psp                   psp"]
#[doc = "| bolos ram <-os stack-| bolos ux ram <-ux_stack-| app ram <-app stack-|"]
#[doc = ""]
#[doc = "ux and app are seen as applications."]
#[doc = "os is not an application (it calls ux upon user inputs)"]
pub use self::bolos_ux_e as bolos_ux_t;
pub type bolos_bool_t = cty::c_char;
pub type bolos_task_status_t = cty::c_uchar;
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut cty::c_uchar,
    pub nvram_end: *mut cty::c_uchar,
    pub main: appmain_t,
    pub flags: cty::c_uint,
    pub code_length: cty::c_uint,
    pub data_length: cty::c_uint,
    pub params_length: cty::c_uint,
    pub sha256_code_data: [cty::c_uchar; 32usize],
    pub sha256_full: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_application_s() {
    assert_eq!(
        ::core::mem::size_of::<application_s>(),
        92usize,
        concat!("Size of: ", stringify!(application_s))
    );
    assert_eq!(
        ::core::mem::align_of::<application_s>(),
        4usize,
        concat!("Alignment of ", stringify!(application_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_begin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_begin)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).nvram_end as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).main as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).code_length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(code_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).data_length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).params_length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(params_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_code_data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_code_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<application_s>())).sha256_full as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_full)
        )
    );
}
pub type application_t = application_s;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: cty::c_uint,
    pub u: bolos_ux_params_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bolos_ux_params_s__bindgen_ty_1 {
    pub boot_unsafe: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1,
    pub appexitb: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2,
    pub appdel: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3,
    pub appadd: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4,
    pub upgrade: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5,
    pub ux_not_signed: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6,
    pub run_app: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7,
    pub customca_key: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8,
    pub foreign_key: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9,
    pub reset_customca: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10,
    pub setup_customca: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11,
    pub keyboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12,
    pub validate_pin: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13,
    pub pin_keyboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14,
    pub status_bar: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15,
    pub loader: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16,
    pub onboard: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17,
    pub boot_delay: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18,
    pub pairing_request: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1 {
    pub currently_onboarded: cty::c_uint,
    pub hash: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>()))
                .currently_onboarded as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(currently_onboarded)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1>())).hash
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hash)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2 {
    pub app_idx: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(app_idx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3 {
    pub app_idx: cty::c_uint,
    pub appentry: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3>())).appentry
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(appentry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4 {
    pub app_idx: cty::c_uint,
    pub appentry: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4>())).appentry
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(appentry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5 {
    pub app_idx: cty::c_uint,
    pub upgrade: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5>())).upgrade
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(upgrade)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6 {
    pub ux_app: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>(),
        92usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6>())).ux_app
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(ux_app)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7 {
    pub app_idx: cty::c_uint,
    pub app: application_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>())).app_idx
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(app_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7>())).app
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(app)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(public)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9 {
    pub host_pubkey: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>(),
        76usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9>())).host_pubkey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(host_pubkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(public)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11 {
    pub name: [cty::c_char; 65usize],
    pub public: cx_ecfp_public_key_t,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>())).name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11>())).public
                as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(public)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12 {
    pub keycode: cty::c_uint,
    pub mode: cty::c_uint,
    pub entered_text: [cty::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>(),
        44usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).keycode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).mode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12>())).entered_text
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(entered_text)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13 {
    pub cancellable: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13>())).cancellable
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(cancellable)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14 {
    pub keycode: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14>())).keycode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(keycode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15 {
    pub fgcolor: cty::c_uint,
    pub bgcolor: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>())).fgcolor
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(fgcolor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15>())).bgcolor
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(bgcolor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16 {
    pub x: cty::c_uint,
    pub y: cty::c_uint,
    pub width: cty::c_uint,
    pub height: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).x
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).y
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).width
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16>())).height
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17 {
    pub id: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17>())).id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18 {
    pub percent: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18>())).percent
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(percent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19 {
    pub type_: bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19__bindgen_ty_1,
    pub pairing_info_len: cty::c_uint,
    pub pairing_info: [cty::c_char; 16usize],
}
pub const bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19_BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_PASSKEY : cty :: c_uint = 0 ;
pub const bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19_BOLOS_UX_ASYNCHMODAL_PAIRING_REQUEST_NUMCOMP : cty :: c_uint = 1 ;
pub type bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19__bindgen_ty_1 = cty::c_uint;
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>())).type_
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>()))
                .pairing_info_len as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(pairing_info_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19>())).pairing_info
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1__bindgen_ty_19),
            "::",
            stringify!(pairing_info)
        )
    );
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s__bindgen_ty_1>(),
        144usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).boot_unsafe as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(boot_unsafe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appexitb as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appexitb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appdel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appdel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).appadd as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(appadd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).upgrade as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(upgrade)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).ux_not_signed as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(ux_not_signed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).run_app as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(run_app)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).customca_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(customca_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).foreign_key as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(foreign_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).reset_customca as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(reset_customca)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).setup_customca as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(setup_customca)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).keyboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).validate_pin as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(validate_pin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).pin_keyboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pin_keyboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).status_bar as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(status_bar)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).loader as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(loader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).onboard as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(onboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).boot_delay as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(boot_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<bolos_ux_params_s__bindgen_ty_1>())).pairing_request as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s__bindgen_ty_1),
            "::",
            stringify!(pairing_request)
        )
    );
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s() {
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s>(),
        152usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).ux_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(ux_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bolos_ux_params_s>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(u)
        )
    );
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_perso_erase_all();
}
extern "C" {
    pub fn os_perso_set_pin(identity: cty::c_uint, pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_set_current_identity_pin(pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    #[doc = " Set the persisted seed if none yet, else override the volatile seed (in RAM)"]
    pub fn os_perso_set_seed(
        identity: cty::c_uint,
        algorithm: cty::c_uint,
        seed: *mut cty::c_uchar,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_and_set_seed(
        identity: cty::c_uchar,
        prefix: *const cty::c_char,
        prefix_length: cty::c_uint,
        passphrase: *const cty::c_char,
        passphrase_length: cty::c_uint,
        words: *const cty::c_char,
        words_length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_words(words: *const cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_finalize();
}
extern "C" {
    pub fn os_perso_isonboarded() -> bolos_bool_t;
}
extern "C" {
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
    );
}
extern "C" {
    pub fn os_perso_derive_node_with_seed_key(
        mode: cty::c_uint,
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
        seed_key: *mut cty::c_uchar,
        seed_key_length: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Generate a seed based cookie"]
    #[doc = " seed => derivation (path 0xda7aba5e/0xc1a551c5) => priv key =SECP256K1=>"]
    #[doc = " pubkey => sha512 => cookie"]
    pub fn os_perso_seed_cookie(
        seed_cookie: *mut cty::c_uchar,
        seed_cookie_length: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_code_hash(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key_certificate(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_get_app_secret(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
}
extern "C" {
    #[doc = " Validating the pin also setup the identity linked with this pin (normal or"]
    #[doc = " alternate)"]
    #[doc = " @return BOLOS_UX_OK if pin validated"]
    pub fn os_global_pin_check(
        pin_buffer: *mut cty::c_uchar,
        pin_length: cty::c_uchar,
    ) -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_invalidate();
}
extern "C" {
    pub fn os_global_pin_retries() -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_count() -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get(index: cty::c_uint, out_application_entry: *mut application_t);
}
extern "C" {
    pub fn os_ux(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
}
extern "C" {
    pub fn os_ux_read_parameters(params: *mut bolos_ux_params_t);
}
extern "C" {
    #[doc = " Wait until a UX call returns a definitve status. Handle all event packets in"]
    #[doc = " between"]
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    #[doc = " Library call function."]
    #[doc = " call_parameters[0] = library name string pointer (const)"]
    #[doc = " call_parameters[1] = library call identifier (0 = init, ...)"]
    #[doc = " call_parameters[2+] = called function parameters"]
    pub fn os_lib_call(call_parameters: *mut cty::c_uint);
}
extern "C" {
    pub fn os_lib_end();
}
extern "C" {
    pub fn os_lib_throw(exception: cty::c_uint);
}
extern "C" {
    pub fn os_flags() -> cty::c_uint;
}
extern "C" {
    pub fn os_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_serial(serial: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_features() -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_bootloader_version(version: *mut cty::c_uchar, maxlength: cty::c_uint)
        -> cty::c_uint;
}
extern "C" {
    pub fn os_get_sn(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
pub const os_setting_e_OS_SETTING_BRIGHTNESS: os_setting_e = 0;
pub const os_setting_e_OS_SETTING_INVERT: os_setting_e = 1;
pub const os_setting_e_OS_SETTING_ROTATION: os_setting_e = 2;
pub const os_setting_e_OS_SETTING_AUTO_LOCK_DELAY: os_setting_e = 3;
pub const os_setting_e_OS_SETTING_POWER_OFF_DELAY: os_setting_e = 4;
pub const os_setting_e_OS_SETTING_PLANEMODE: os_setting_e = 5;
pub const os_setting_e_OS_SETTING_PRIVACY_MODE: os_setting_e = 6;
pub const os_setting_e_OS_SETTING_LAST_INT: os_setting_e = 7;
pub const os_setting_e_OS_SETTING_SAVER_STRING: os_setting_e = 7;
pub const os_setting_e_OS_SETTING_DEVICENAME: os_setting_e = 8;
pub const os_setting_e_OS_SETTING_BLEMACADR: os_setting_e = 9;
pub const os_setting_e_OS_SETTING_LAST: os_setting_e = 10;
pub type os_setting_e = cty::c_uint;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    #[doc = " Retrieve the value of a setting in a user specified buffer, with a max"]
    #[doc = " length, and return the effective returned length."]
    pub fn os_setting_get(
        setting_id: cty::c_uint,
        value: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    #[doc = " Define a setting's value from a user buffer and its length. In case of error,"]
    #[doc = " a throw is executed."]
    pub fn os_setting_set(setting_id: cty::c_uint, value: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn screen_printf(format: *const cty::c_char, ...);
}
extern "C" {
    pub fn screen_printc(c: cty::c_uchar);
}
extern "C" {
    pub fn snprintf(
        str_: *mut cty::c_char,
        str_size: cty::c_uint,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: cty::c_uint,
    pub appMemory: cty::c_uint,
    pub systemSize: cty::c_uint,
    pub slots: cty::c_uint,
}
#[test]
fn bindgen_test_layout_meminfo_s() {
    assert_eq!(
        ::core::mem::size_of::<meminfo_s>(),
        16usize,
        concat!("Size of: ", stringify!(meminfo_s))
    );
    assert_eq!(
        ::core::mem::align_of::<meminfo_s>(),
        4usize,
        concat!("Alignment of ", stringify!(meminfo_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).free_nvram_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(free_nvram_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).appMemory as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(appMemory)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).systemSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(systemSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<meminfo_s>())).slots as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(slots)
        )
    );
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
}
extern "C" {
    #[doc = " @param appidx The application entry index in the registry (raw, not filtering"]
    #[doc = " ux or whatever). If the entry index correspond to the application being"]
    #[doc = " installed then RAM structure content is used instead of the NVRAM registry."]
    #[doc = " @param tlvoffset The offset within the install parameters memory area, in"]
    #[doc = " bytes. Useful if tag is present multiple times. Can be null. The tlv offset"]
    #[doc = " is the offset of the tag in the install parameters area when a tag is"]
    #[doc = " matched. This way long tag can be read in multiple time without the need to"]
    #[doc = " play with the tlvoffset. Add +1 to skip to the next one when seraching for"]
    #[doc = " multiple tag occurences."]
    #[doc = " @param tag The tag to be searched for"]
    #[doc = " @param value_offset The offset within the value for this occurence of the"]
    #[doc = " tag. The OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER or"]
    #[doc = " OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH can be ORed to perform meta operation"]
    #[doc = " on the TLV occurence."]
    #[doc = " @param buffer The user buffer for comparison or to retrieve the value of the"]
    #[doc = " tag at the given offset."]
    #[doc = " @param maxlength Size of the buffer to be compared OR to be retrieved"]
    #[doc = " (trimmed depending the TLV effective length)."]
    pub fn os_registry_get_tag(
        appidx: cty::c_uint,
        tlvoffset: *mut cty::c_uint,
        tag: cty::c_uint,
        value_offset: cty::c_uint,
        buffer: *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get_current_app_tag(
        tag: cty::c_uint,
        buffer: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_customca_verify(
        hash: *mut cty::c_uchar,
        sign: *mut cty::c_uchar,
        sign_length: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn safe_desynch();
}
pub const os_watchdog_behavior_t_OS_WATCHDOG_NOACTION: os_watchdog_behavior_t = 0;
pub const os_watchdog_behavior_t_OS_WATCHDOG_RESET: os_watchdog_behavior_t = 1;
pub const os_watchdog_behavior_t_OS_WATCHDOG_WIPE: os_watchdog_behavior_t = 2;
pub type os_watchdog_behavior_t = cty::c_uint;
extern "C" {
    #[doc = " This function arm a low level watchdog, when the value is consumed, and"]
    #[doc = " depending on the requested behavior, an action can be taken."]
    #[doc = " @throw INVALID_PARAMETER when the useconds value overflows the possible"]
    #[doc = " value."]
    pub fn os_watchdog_arm(useconds: cty::c_uint, behavior: os_watchdog_behavior_t);
}
extern "C" {
    #[doc = " This function returns the number of useconds to be still consumed by the"]
    #[doc = " watchdog (when > 0), or the overflowed useconds after the watchdog has timed"]
    #[doc = " out (when < 0)"]
    pub fn os_watchdog_value() -> cty::c_int;
}
pub const task_unsecure_id_e_TASK_BOLOS: task_unsecure_id_e = 0;
pub const task_unsecure_id_e_TASK_SYSCALL: task_unsecure_id_e = 1;
pub const task_unsecure_id_e_TASK_USERTASKS_START: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_USER: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_SUBTASKS_START: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_SUBTASK_0: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_BOLOS_UX: task_unsecure_id_e = 4;
pub const task_unsecure_id_e_TASK_MAXCOUNT: task_unsecure_id_e = 5;
pub type task_unsecure_id_e = cty::c_uint;
extern "C" {
    pub fn os_sched_exec(application_index: cty::c_uint);
}
extern "C" {
    pub fn os_sched_exit(exit_code: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_is_running(task_idx: cty::c_uint) -> bolos_bool_t;
}
extern "C" {
    #[doc = " Retrieve the last status issued by a task using either yield or exit."]
    pub fn os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
}
extern "C" {
    pub fn svc_os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
}
extern "C" {
    #[doc = " Current task is yielding the process to another task."]
    #[doc = " Meta call for task_switch with 'the enxt' task idx."]
    #[doc = " @param status is the current task status"]
    pub fn os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    pub fn svc_os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Perform task switching"]
    #[doc = " @param registry_app_idx is the application registry index to switch into"]
    #[doc = " @param status of the currently executed task"]
    #[doc = " @return the status of the previously running task"]
    pub fn os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
}
extern "C" {
    pub fn svc_os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Function that returns the currently running task identifier."]
    pub fn os_sched_current_task() -> cty::c_uint;
}
extern "C" {
    pub fn svc_os_sched_current_task() -> cty::c_uint;
}
extern "C" {
    #[doc = " Create a new task with the given parameters and return its task identifier."]
    #[doc = " The newly created task is chrooted in the given nvram/ram1/ram2 segments"]
    #[doc = " and its task pointer is set at the end of ram1 segment."]
    #[doc = " The task is bound to the currently running application."]
    #[doc = " The task identifiers are not garanteed to be the same after a power cycle."]
    #[doc = " At least valid main, nvram segment, ram0 segment and stack segment must be"]
    #[doc = " provided with."]
    #[doc = " @param permissions to give to the task, permissions is a AND mask with the"]
    #[doc = " application's installation flags (can only reduce scope, never grant more)."]
    #[doc = " @param main The main function address to start the task with."]
    #[doc = " @param nvram The nvram segment address start"]
    #[doc = " @param nvram_length The nvram segment length"]
    #[doc = " @param ram0 /ram0_length the first RAM segment description"]
    #[doc = " @param ram1 /ram1_length the second RAM segment description"]
    #[doc = " @param stack /stack_length the task's stack RAM segment description"]
    pub fn os_sched_create(
        permissions: cty::c_uint,
        main: *mut cty::c_void,
        nvram: *mut cty::c_void,
        nvram_length: cty::c_uint,
        ram0: *mut cty::c_void,
        ram0_length: cty::c_uint,
        ram1: *mut cty::c_void,
        ram1_length: cty::c_uint,
        stack: *mut cty::c_void,
        stack_length: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_sched_kill(taskidx: cty::c_uint);
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut cty::c_uchar,
        mem_len: cty::c_uint,
        tlv_instance_offset: *mut cty::c_uint,
        tag: cty::c_uint,
        offset: cty::c_uint,
        buffer: *mut *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_paging_params_s {
    pub title: *const cty::c_char,
    pub text: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_paging_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_paging_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_paging_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_paging_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_paging_params_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_layout_paging_params_s>())).title as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_paging_params_s),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_paging_params_s>())).text as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_paging_params_s),
            "::",
            stringify!(text)
        )
    );
}
pub type ux_layout_paging_params_t = ux_layout_paging_params_s;
extern "C" {
    pub fn ux_layout_paging_init(stack_slot: cty::c_uint);
}
extern "C" {
    pub fn ux_layout_paging_reset();
}
#[doc = " 2 text lines"]
#[doc = " 1 bold text lines"]
#[doc = " 2 text lines"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_nnbnn_params_s {
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
    pub line3: *const cty::c_char,
    pub line4: *const cty::c_char,
    pub line5: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_nnbnn_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_nnbnn_params_s>(),
        20usize,
        concat!("Size of: ", stringify!(ux_layout_nnbnn_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_nnbnn_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_nnbnn_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nnbnn_params_s>())).line1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nnbnn_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nnbnn_params_s>())).line2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nnbnn_params_s),
            "::",
            stringify!(line2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nnbnn_params_s>())).line3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nnbnn_params_s),
            "::",
            stringify!(line3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nnbnn_params_s>())).line4 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nnbnn_params_s),
            "::",
            stringify!(line4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nnbnn_params_s>())).line5 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nnbnn_params_s),
            "::",
            stringify!(line5)
        )
    );
}
#[doc = " 2 text lines"]
#[doc = " 1 bold text lines"]
#[doc = " 2 text lines"]
pub type ux_layout_nnbnn_params_t = ux_layout_nnbnn_params_s;
extern "C" {
    pub fn ux_layout_nnbnn_init(stack_slot: cty::c_uint);
}
#[doc = " ICON"]
#[doc = " 1 bold text line"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_pb_params_s {
    pub icon: *const bagl_icon_details_t,
    pub line1: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_pb_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_pb_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_pb_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_pb_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_pb_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pb_params_s>())).icon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pb_params_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pb_params_s>())).line1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pb_params_s),
            "::",
            stringify!(line1)
        )
    );
}
#[doc = " ICON"]
#[doc = " 1 bold text line"]
pub type ux_layout_pb_params_t = ux_layout_pb_params_s;
extern "C" {
    pub fn ux_layout_pb_init(stack_slot: cty::c_uint);
}
#[doc = " 2 bold text line"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_bb_params_s {
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_bb_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_bb_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_bb_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_bb_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_bb_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_bb_params_s>())).line1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_bb_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_bb_params_s>())).line2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_bb_params_s),
            "::",
            stringify!(line2)
        )
    );
}
#[doc = " 2 bold text line"]
pub type ux_layout_bb_params_t = ux_layout_bb_params_s;
extern "C" {
    pub fn ux_layout_bb_init(stack_slot: cty::c_uint);
}
#[doc = " 1 text line"]
#[doc = " 1 bold text line"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_bn_params_s {
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_bn_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_bn_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_bn_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_bn_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_bn_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_bn_params_s>())).line1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_bn_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_bn_params_s>())).line2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_bn_params_s),
            "::",
            stringify!(line2)
        )
    );
}
#[doc = " 1 text line"]
#[doc = " 1 bold text line"]
pub type ux_layout_bn_params_t = ux_layout_bn_params_s;
extern "C" {
    pub fn ux_layout_bn_init(stack_slot: cty::c_uint);
}
#[doc = " ICON"]
#[doc = " 2 bold text lines"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_pbb_params_s {
    pub icon: *const bagl_icon_details_t,
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_pbb_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_pbb_params_s>(),
        12usize,
        concat!("Size of: ", stringify!(ux_layout_pbb_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_pbb_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_pbb_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pbb_params_s>())).icon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pbb_params_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pbb_params_s>())).line1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pbb_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pbb_params_s>())).line2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pbb_params_s),
            "::",
            stringify!(line2)
        )
    );
}
#[doc = " ICON"]
#[doc = " 2 bold text lines"]
pub type ux_layout_pbb_params_t = ux_layout_pbb_params_s;
extern "C" {
    pub fn ux_layout_pbb_init(stack_slot: cty::c_uint);
}
#[doc = " ICON"]
#[doc = " 2 normal text lines"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_pnn_params_s {
    pub icon: *const bagl_icon_details_t,
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_pnn_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_pnn_params_s>(),
        12usize,
        concat!("Size of: ", stringify!(ux_layout_pnn_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_pnn_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_pnn_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pnn_params_s>())).icon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pnn_params_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pnn_params_s>())).line1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pnn_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pnn_params_s>())).line2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pnn_params_s),
            "::",
            stringify!(line2)
        )
    );
}
#[doc = " ICON"]
#[doc = " 2 normal text lines"]
pub type ux_layout_pnn_params_t = ux_layout_pnn_params_s;
extern "C" {
    pub fn ux_layout_pnn_init(stack_slot: cty::c_uint);
}
#[doc = " ICON"]
#[doc = " 1 normal text lines"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_pn_params_s {
    pub icon: *const bagl_icon_details_t,
    pub line1: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_pn_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_pn_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_pn_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_pn_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_pn_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pn_params_s>())).icon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pn_params_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_pn_params_s>())).line1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_pn_params_s),
            "::",
            stringify!(line1)
        )
    );
}
#[doc = " ICON"]
#[doc = " 1 normal text lines"]
pub type ux_layout_pn_params_t = ux_layout_pn_params_s;
extern "C" {
    pub fn ux_layout_pn_init(stack_slot: cty::c_uint);
}
#[doc = " 2 normal text lines"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_nn_params_s {
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_layout_nn_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_nn_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(ux_layout_nn_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_nn_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_nn_params_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nn_params_s>())).line1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nn_params_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_layout_nn_params_s>())).line2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_nn_params_s),
            "::",
            stringify!(line2)
        )
    );
}
#[doc = " 2 normal text lines"]
pub type ux_layout_nn_params_t = ux_layout_nn_params_s;
extern "C" {
    pub fn ux_layout_nn_init(stack_slot: cty::c_uint);
}
#[doc = " Browsable component"]
pub type list_item_select_t = ::core::option::Option<unsafe extern "C" fn(item_idx: cty::c_uint)>;
pub type list_item_value_t =
    ::core::option::Option<unsafe extern "C" fn(item_idx: cty::c_uint) -> *const cty::c_char>;
extern "C" {
    pub fn ux_menulist_init(
        stack_slot: cty::c_uint,
        getter: list_item_value_t,
        selector: list_item_select_t,
    );
}
extern "C" {
    pub fn ux_menulist_init_select(
        stack_slot: cty::c_uint,
        getter: list_item_value_t,
        selector: list_item_select_t,
        selected_item_idx: cty::c_uint,
    );
}
extern "C" {
    #[doc = " Set the timeout before auto validation of the step currently displayed"]
    #[doc = " (must be called after layout init function)."]
    pub fn ux_layout_set_timeout(stack_slot: cty::c_uint, ms: cty::c_uint);
}
pub type ux_flow_step_t = ux_flow_step_s;
#[doc = " Relatively static UX flow description framework"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_flow_state_t {
    pub steps: *const *const ux_flow_step_t,
    pub index: cty::c_ushort,
    pub prev_index: cty::c_ushort,
    pub length: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_ux_flow_state_t() {
    assert_eq!(
        ::core::mem::size_of::<ux_flow_state_t>(),
        12usize,
        concat!("Size of: ", stringify!(ux_flow_state_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_flow_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_flow_state_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_state_t>())).steps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_state_t),
            "::",
            stringify!(steps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_state_t>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_state_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_state_t>())).prev_index as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_state_t),
            "::",
            stringify!(prev_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_state_t>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_state_t),
            "::",
            stringify!(length)
        )
    );
}
pub type ux_flow_step_init_t =
    ::core::option::Option<unsafe extern "C" fn(stack_slot: cty::c_uint)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_flow_step_s {
    pub init: ux_flow_step_init_t,
    pub params: *const cty::c_void,
    pub validate_flow: *const *const ux_flow_step_t,
    pub error_flow: *const *const ux_flow_step_t,
}
#[test]
fn bindgen_test_layout_ux_flow_step_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_flow_step_s>(),
        16usize,
        concat!("Size of: ", stringify!(ux_flow_step_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_flow_step_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_flow_step_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_step_s>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_step_s),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_step_s>())).params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_step_s),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_step_s>())).validate_flow as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_step_s),
            "::",
            stringify!(validate_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_flow_step_s>())).error_flow as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_flow_step_s),
            "::",
            stringify!(error_flow)
        )
    );
}
extern "C" {
    pub fn ux_flow_is_first() -> cty::c_uint;
}
extern "C" {
    pub fn ux_flow_is_last() -> cty::c_uint;
}
pub const ux_flow_direction_t_FLOW_DIRECTION_BACKWARD: ux_flow_direction_t = -1;
pub const ux_flow_direction_t_FLOW_DIRECTION_START: ux_flow_direction_t = 0;
pub const ux_flow_direction_t_FLOW_DIRECTION_FORWARD: ux_flow_direction_t = 1;
pub type ux_flow_direction_t = cty::c_int;
extern "C" {
    pub fn ux_flow_direction() -> ux_flow_direction_t;
}
extern "C" {
    pub fn ux_flow_step() -> *const ux_flow_step_t;
}
extern "C" {
    pub fn ux_flow_next_no_display();
}
extern "C" {
    pub fn ux_flow_next();
}
extern "C" {
    pub fn ux_flow_prev();
}
extern "C" {
    pub fn ux_flow_validate();
}
extern "C" {
    pub fn ux_flow_error(error: cty::c_uint);
}
extern "C" {
    pub fn ux_flow_button_callback(
        button_mask: cty::c_uint,
        button_mask_counter: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn ux_stack_get_current_step_params() -> *mut cty::c_void;
}
extern "C" {
    pub fn ux_stack_get_step_params(stack_slot: cty::c_uint) -> *mut cty::c_void;
}
extern "C" {
    #[doc = " Return 0 when no relayout occured."]
    pub fn ux_flow_relayout() -> cty::c_uint;
}
extern "C" {
    pub fn ux_flow_init(
        stack_slot: cty::c_uint,
        steps: *const *const ux_flow_step_t,
        start_step: *const ux_flow_step_t,
    );
}
extern "C" {
    #[doc = " Wipe a flow definition from a flow stack slot"]
    pub fn ux_flow_uninit(stack_slot: cty::c_uint);
}
pub type bagl_element_t = bagl_element_e;
pub type bagl_element_callback_t = ::core::option::Option<
    unsafe extern "C" fn(element: *const bagl_element_t) -> *const bagl_element_t,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_element_e {
    pub component: bagl_component_t,
    pub text: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_bagl_element_e() {
    assert_eq!(
        ::core::mem::size_of::<bagl_element_e>(),
        36usize,
        concat!("Size of: ", stringify!(bagl_element_e))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_element_e>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_element_e))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_element_e>())).component as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_element_e),
            "::",
            stringify!(component)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bagl_element_e>())).text as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_element_e),
            "::",
            stringify!(text)
        )
    );
}
extern "C" {
    pub fn io_seproxyhal_touch(
        elements: *const bagl_element_t,
        element_count: cty::c_ushort,
        x: cty::c_ushort,
        y: cty::c_ushort,
        event_kind: cty::c_uchar,
    );
}
extern "C" {
    pub fn io_seproxyhal_touch_element_callback(
        elements: *const bagl_element_t,
        element_count: cty::c_ushort,
        x: cty::c_ushort,
        y: cty::c_ushort,
        event_kind: cty::c_uchar,
        before_display: bagl_element_callback_t,
    );
}
extern "C" {
    pub fn io_seproxyhal_touch_callback(element: *const bagl_element_t, event: cty::c_uchar);
}
extern "C" {
    #[doc = " Common strings prepro tosave space"]
    pub fn ux_layout_strings_prepro(element: *const bagl_element_t) -> *const bagl_element_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_strings_params_s {
    pub lines: [*const cty::c_char; 5usize],
}
#[test]
fn bindgen_test_layout_ux_layout_strings_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_strings_params_s>(),
        20usize,
        concat!("Size of: ", stringify!(ux_layout_strings_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_strings_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_strings_params_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_layout_strings_params_s>())).lines as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_strings_params_s),
            "::",
            stringify!(lines)
        )
    );
}
pub type ux_layout_strings_params_t = ux_layout_strings_params_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_layout_icon_strings_params_s {
    pub icon: *const bagl_icon_details_t,
    pub lines: [*const cty::c_char; 5usize],
}
#[test]
fn bindgen_test_layout_ux_layout_icon_strings_params_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_layout_icon_strings_params_s>(),
        24usize,
        concat!("Size of: ", stringify!(ux_layout_icon_strings_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_layout_icon_strings_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_layout_icon_strings_params_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_layout_icon_strings_params_s>())).icon as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_icon_strings_params_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_layout_icon_strings_params_s>())).lines as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_layout_icon_strings_params_s),
            "::",
            stringify!(lines)
        )
    );
}
pub type ux_layout_icon_strings_params_t = ux_layout_icon_strings_params_s;
pub type button_push_callback_t = ::core::option::Option<
    unsafe extern "C" fn(button_mask: cty::c_uint, button_mask_counter: cty::c_uint) -> cty::c_uint,
>;
extern "C" {
    pub fn io_seproxyhal_button_push(
        button_push_callback: button_push_callback_t,
        new_button_mask: cty::c_uint,
    );
}
extern "C" {
    pub fn io_seproxyhal_display(element: *const bagl_element_t);
}
extern "C" {
    pub fn bagl_label_roundtrip_duration_ms(
        e: *const bagl_element_t,
        average_char_width: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn bagl_label_roundtrip_duration_ms_buf(
        e: *const bagl_element_t,
        str_: *const cty::c_char,
        average_char_width: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_display_default(element: *const bagl_element_t);
}
pub type callback_int_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_uint) -> cty::c_uint>;
pub type asynchmodal_end_callback_t =
    ::core::option::Option<unsafe extern "C" fn(ux_status: cty::c_uint)>;
pub type ux_stack_slot_t = ux_stack_slot_s;
#[doc = " Common structure for applications to perform asynchronous UX aside IO operations"]
pub type ux_state_t = ux_state_s;
extern "C" {
    pub fn ux_stack_is_element_array_present(element_array: *const bagl_element_t) -> cty::c_uint;
}
extern "C" {
    pub fn ux_stack_push() -> cty::c_uint;
}
extern "C" {
    pub fn ux_stack_pop() -> cty::c_uint;
}
extern "C" {
    pub fn ux_stack_insert(stack_slot: cty::c_uint);
}
extern "C" {
    pub fn ux_stack_remove(stack_slot: cty::c_uint);
}
extern "C" {
    pub fn ux_stack_init(stack_slot: cty::c_uint);
}
extern "C" {
    pub fn ux_stack_display(stack_slot: cty::c_uint);
}
extern "C" {
    #[doc = " Function to be implemented by the UX manager (to allow specific callback and processing of the target)"]
    #[doc = " The next displayable element of the given stack slot must be displayed"]
    pub fn ux_stack_al_display_next_element(stack_slot: cty::c_uint);
}
extern "C" {
    pub fn ux_stack_redisplay();
}
extern "C" {
    pub fn ux_stack_display_element_callback(
        element: *const bagl_element_t,
    ) -> *const bagl_element_t;
}
pub type ux_menu_callback_t = ::core::option::Option<unsafe extern "C" fn(userid: cty::c_uint)>;
pub type ux_menu_entry_t = ux_menu_entry_s;
#[doc = " Menu entry descriptor."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_menu_entry_s {
    pub menu: *const ux_menu_entry_t,
    pub callback: ux_menu_callback_t,
    pub userid: cty::c_uint,
    pub icon: *const bagl_icon_details_t,
    pub line1: *const cty::c_char,
    pub line2: *const cty::c_char,
    pub text_x: cty::c_char,
    pub icon_x: cty::c_char,
}
#[test]
fn bindgen_test_layout_ux_menu_entry_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_menu_entry_s>(),
        28usize,
        concat!("Size of: ", stringify!(ux_menu_entry_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_menu_entry_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_menu_entry_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).menu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).callback as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).userid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(userid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).icon as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).line1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).line2 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(line2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).text_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(text_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_entry_s>())).icon_x as *const _ as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_entry_s),
            "::",
            stringify!(icon_x)
        )
    );
}
pub type ux_menu_preprocessor_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ux_menu_entry_t,
        element: *mut bagl_element_t,
    ) -> *const bagl_element_t,
>;
pub type ux_menu_iterator_t =
    ::core::option::Option<unsafe extern "C" fn(entry_idx: cty::c_uint) -> *const ux_menu_entry_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_menu_state_s {
    pub menu_entries: *const ux_menu_entry_t,
    pub menu_entries_count: cty::c_uint,
    pub current_entry: cty::c_uint,
    pub menu_entry_preprocessor: ux_menu_preprocessor_t,
    pub menu_iterator: ux_menu_iterator_t,
}
#[test]
fn bindgen_test_layout_ux_menu_state_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_menu_state_s>(),
        20usize,
        concat!("Size of: ", stringify!(ux_menu_state_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_menu_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_menu_state_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_state_s>())).menu_entries as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_state_s),
            "::",
            stringify!(menu_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_menu_state_s>())).menu_entries_count as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_state_s),
            "::",
            stringify!(menu_entries_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_state_s>())).current_entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_state_s),
            "::",
            stringify!(current_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_menu_state_s>())).menu_entry_preprocessor as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_state_s),
            "::",
            stringify!(menu_entry_preprocessor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_menu_state_s>())).menu_iterator as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_menu_state_s),
            "::",
            stringify!(menu_iterator)
        )
    );
}
pub type ux_menu_state_t = ux_menu_state_s;
pub type ux_turner_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_turner_step_s {
    pub icon: *const bagl_icon_details_t,
    pub fontid1: cty::c_ushort,
    pub line1: *const cty::c_char,
    pub fontid2: cty::c_ushort,
    pub line2: *const cty::c_char,
    pub text_x: cty::c_char,
    pub icon_x: cty::c_char,
    pub next_step_ms: cty::c_uint,
}
#[test]
fn bindgen_test_layout_ux_turner_step_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_turner_step_s>(),
        28usize,
        concat!("Size of: ", stringify!(ux_turner_step_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_turner_step_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_turner_step_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).icon as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(icon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).fontid1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(fontid1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).line1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(line1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).fontid2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(fontid2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).line2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(line2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).text_x as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(text_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).icon_x as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(icon_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_step_s>())).next_step_ms as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_step_s),
            "::",
            stringify!(next_step_ms)
        )
    );
}
pub type ux_turner_step_t = ux_turner_step_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_turner_state_s {
    pub steps: *const ux_turner_step_t,
    pub steps_count: cty::c_uint,
    pub current_step: cty::c_uint,
    pub button_callback: button_push_callback_t,
    pub elapsed_ms: cty::c_uint,
}
#[test]
fn bindgen_test_layout_ux_turner_state_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_turner_state_s>(),
        20usize,
        concat!("Size of: ", stringify!(ux_turner_state_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_turner_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_turner_state_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_state_s>())).steps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_state_s),
            "::",
            stringify!(steps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_state_s>())).steps_count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_state_s),
            "::",
            stringify!(steps_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_state_s>())).current_step as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_state_s),
            "::",
            stringify!(current_step)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_turner_state_s>())).button_callback as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_state_s),
            "::",
            stringify!(button_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_turner_state_s>())).elapsed_ms as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_turner_state_s),
            "::",
            stringify!(elapsed_ms)
        )
    );
}
pub type ux_turner_state_t = ux_turner_state_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_stack_slot_s {
    pub exit_code_after_elements_displayed: bolos_task_status_t,
    pub element_arrays_count: cty::c_uchar,
    pub element_index: cty::c_ushort,
    pub element_arrays: [ux_stack_slot_s__bindgen_ty_1; 1usize],
    pub screen_before_element_display_callback: bagl_element_callback_t,
    pub button_push_callback: button_push_callback_t,
    pub ticker_callback: callback_int_t,
    pub ticker_value: cty::c_uint,
    pub ticker_interval: cty::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ux_stack_slot_s__bindgen_ty_1 {
    pub element_array: *const bagl_element_t,
    pub element_array_count: cty::c_uchar,
}
#[test]
fn bindgen_test_layout_ux_stack_slot_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ux_stack_slot_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ux_stack_slot_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_stack_slot_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_stack_slot_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s__bindgen_ty_1>())).element_array as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s__bindgen_ty_1),
            "::",
            stringify!(element_array)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s__bindgen_ty_1>())).element_array_count
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s__bindgen_ty_1),
            "::",
            stringify!(element_array_count)
        )
    );
}
#[test]
fn bindgen_test_layout_ux_stack_slot_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_stack_slot_s>(),
        32usize,
        concat!("Size of: ", stringify!(ux_stack_slot_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_stack_slot_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_stack_slot_s))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).exit_code_after_elements_displayed
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(exit_code_after_elements_displayed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).element_arrays_count as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(element_arrays_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_stack_slot_s>())).element_index as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(element_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_stack_slot_s>())).element_arrays as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(element_arrays)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).screen_before_element_display_callback
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(screen_before_element_display_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).button_push_callback as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(button_push_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).ticker_callback as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(ticker_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_stack_slot_s>())).ticker_value as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(ticker_value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ux_stack_slot_s>())).ticker_interval as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_stack_slot_s),
            "::",
            stringify!(ticker_interval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ux_state_s {
    pub stack_count: cty::c_uchar,
    pub exit_code: bolos_task_status_t,
    pub tmp_element: bagl_element_t,
    pub stack: [ux_stack_slot_t; 1usize],
    pub menulist_current: cty::c_uint,
    pub menulist_params: ux_layout_strings_params_t,
    pub menulist_getter: list_item_value_t,
    pub menulist_selector: list_item_select_t,
    pub params: bolos_ux_params_t,
}
#[test]
fn bindgen_test_layout_ux_state_s() {
    assert_eq!(
        ::core::mem::size_of::<ux_state_s>(),
        256usize,
        concat!("Size of: ", stringify!(ux_state_s))
    );
    assert_eq!(
        ::core::mem::align_of::<ux_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(ux_state_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).stack_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(stack_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).exit_code as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(exit_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).tmp_element as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(tmp_element)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).stack as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).menulist_current as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(menulist_current)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).menulist_params as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(menulist_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).menulist_getter as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(menulist_getter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).menulist_selector as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(menulist_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ux_state_s>())).params as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ux_state_s),
            "::",
            stringify!(params)
        )
    );
}
extern "C" {
    pub static mut ux: ux_state_t;
}
extern "C" {
    #[doc = " Setup the TICKER_EVENT interval. Application shall not use this entry point as it's the main ticking source. Use the ::UX_SET_INTERVAL_MS instead."]
    pub fn io_seproxyhal_setup_ticker(interval_ms: cty::c_uint);
}
extern "C" {
    pub fn io_seproxyhal_request_mcu_status();
}
extern "C" {
    #[doc = " Helper function to order the MCU to display the given bitmap with the given color index, a table of size: (1<<bit_per_pixel) with little endian encoded colors."]
    #[doc = " Deprecated"]
    pub fn io_seproxyhal_display_bitmap(
        x: cty::c_int,
        y: cty::c_int,
        w: cty::c_uint,
        h: cty::c_uint,
        color_index: *mut cty::c_uint,
        bit_per_pixel: cty::c_uint,
        bitmap: *mut cty::c_uchar,
    );
}
extern "C" {
    pub fn io_seproxyhal_power_off();
}
extern "C" {
    pub fn io_seproxyhal_se_reset();
}
extern "C" {
    pub fn io_seproxyhal_disable_io();
}
extern "C" {
    pub fn io_seproxyhal_backlight(flags: cty::c_uint, backlight_percentage: cty::c_uint);
}
extern "C" {
    #[doc = " Helper function to send the given bitmap splitting into multiple DISPLAY_RAW packet as the bitmap is not meant to fit in a single SEPROXYHAL packet."]
    pub fn io_seproxyhal_display_icon(
        icon_component: *mut bagl_component_t,
        icon_details: *mut bagl_icon_details_t,
    );
}
extern "C" {
    #[doc = " Helper method on the Blue to output icon header to the MCU and allow for bitmap transformation"]
    pub fn io_seproxyhal_display_icon_header_and_colors(
        icon_component: *mut bagl_component_t,
        icon_details: *mut bagl_icon_details_t,
        icon_len: *mut cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn ux_menu_display(
        current_entry: cty::c_uint,
        menu_entries: *const ux_menu_entry_t,
        menu_entry_preprocessor: ux_menu_preprocessor_t,
    );
}
extern "C" {
    pub fn ux_menu_element_preprocessor(element: *const bagl_element_t) -> *const bagl_element_t;
}
extern "C" {
    pub fn ux_menu_elements_button(
        button_mask: cty::c_uint,
        button_mask_counter: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub static mut ux_menu: ux_menu_state_t;
}
extern "C" {
    pub fn ux_turner_display(
        current_step: cty::c_uint,
        steps: *const ux_turner_step_t,
        steps_count: cty::c_uint,
        button_callback: button_push_callback_t,
    );
}
extern "C" {
    pub fn ux_turner_ticker(elpased_ms: cty::c_uint);
}
extern "C" {
    pub static mut ux_turner: ux_turner_state_t;
}
extern "C" {
    pub static mut G_io_seproxyhal_spi_buffer: [cty::c_uchar; 128usize];
}
extern "C" {
    pub fn io_seph_send(buffer: *const cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_seph_is_status_sent() -> cty::c_uint;
}
extern "C" {
    pub fn io_seph_recv(
        buffer: *mut cty::c_uchar,
        maxlength: cty::c_ushort,
        flags: cty::c_uint,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn io_seph_init();
}
extern "C" {
    pub fn io_seproxyhal_init();
}
extern "C" {
    pub fn io_seproxyhal_init_ux();
}
extern "C" {
    pub fn io_seproxyhal_init_button();
}
extern "C" {
    pub fn io_exchange_al(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
extern "C" {
    pub fn os_io_seproxyhal_get_app_name_and_version() -> cty::c_uint;
}
extern "C" {
    pub fn USB_power(enabled: cty::c_uchar);
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_event();
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_ep_xfer_event();
}
extern "C" {
    pub fn io_seproxyhal_get_ep_rx_size(epnum: u8) -> u16;
}
extern "C" {
    pub fn io_seproxyhal_handle_event() -> cty::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_general_status();
}
extern "C" {
    pub fn os_io_seproxyhal_general_status_processing();
}
extern "C" {
    pub fn io_usb_send_apdu_data(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_apdu_data_ep0x83(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_ep(
        ep: cty::c_uint,
        buffer: *mut cty::c_uchar,
        length: cty::c_ushort,
        timeout: cty::c_uint,
    );
}
extern "C" {
    pub fn io_usb_ccid_reply(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_set_timeout(timeout: cty::c_uint);
}
pub const io_apdu_state_e_APDU_IDLE: io_apdu_state_e = 0;
pub const io_apdu_state_e_APDU_BLE: io_apdu_state_e = 1;
pub const io_apdu_state_e_APDU_BLE_WAIT_NOTIFY: io_apdu_state_e = 2;
pub const io_apdu_state_e_APDU_NFC_M24SR: io_apdu_state_e = 3;
pub const io_apdu_state_e_APDU_NFC_M24SR_SELECT: io_apdu_state_e = 4;
pub const io_apdu_state_e_APDU_NFC_M24SR_FIRST: io_apdu_state_e = 5;
pub const io_apdu_state_e_APDU_NFC_M24SR_RAPDU: io_apdu_state_e = 6;
pub const io_apdu_state_e_APDU_USB_HID: io_apdu_state_e = 7;
pub const io_apdu_state_e_APDU_USB_CCID: io_apdu_state_e = 8;
pub const io_apdu_state_e_APDU_U2F: io_apdu_state_e = 9;
pub const io_apdu_state_e_APDU_RAW: io_apdu_state_e = 10;
pub const io_apdu_state_e_APDU_USB_WEBUSB: io_apdu_state_e = 11;
pub type io_apdu_state_e = cty::c_uint;
extern "C" {
    pub fn mcu_usb_printc(c: cty::c_uchar);
}
#[doc = " Global type that enables to map memory onto the application zone instead of"]
#[doc = " over the os for os side"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_seph_s {
    pub apdu_state: io_apdu_state_e,
    pub apdu_length: cty::c_ushort,
    pub io_flags: cty::c_ushort,
    pub apdu_media: io_apdu_media_t,
    pub ms: cty::c_uint,
    pub usb_ep_xfer_len: [cty::c_uchar; 7usize],
    pub usb_ep_timeouts: [io_seph_s__bindgen_ty_1; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_seph_s__bindgen_ty_1 {
    pub timeout: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_io_seph_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<io_seph_s__bindgen_ty_1>())).timeout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_io_seph_s() {
    assert_eq!(
        ::core::mem::size_of::<io_seph_s>(),
        40usize,
        concat!("Size of: ", stringify!(io_seph_s))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s>(),
        4usize,
        concat!("Alignment of ", stringify!(io_seph_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_length)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).io_flags as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(io_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).apdu_media as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_media)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).ms as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).usb_ep_xfer_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_xfer_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<io_seph_s>())).usb_ep_timeouts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_timeouts)
        )
    );
}
#[doc = " Global type that enables to map memory onto the application zone instead of"]
#[doc = " over the os for os side"]
pub type io_seph_app_t = io_seph_s;
extern "C" {
    pub static mut G_io_app: io_seph_app_t;
}
extern "C" {
    pub fn io_seproxyhal_disable_ble();
}
extern "C" {
    #[doc = " Function to ensure a I/O channel is not timeouting waiting for operations"]
    #[doc = " after a long time without SEPH packet exchanges"]
    pub fn io_seproxyhal_io_heartbeat();
}
pub type io_send_t =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut cty::c_uchar, length: cty::c_ushort)>;
pub type io_recv_t = ::core::option::Option<
    unsafe extern "C" fn(buffer: *mut cty::c_uchar, maxlenth: cty::c_ushort) -> cty::c_ushort,
>;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RESET: io_usb_hid_receive_status_e = 0;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_MORE_DATA: io_usb_hid_receive_status_e = 1;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RECEIVED: io_usb_hid_receive_status_e = 2;
pub type io_usb_hid_receive_status_e = cty::c_uint;
pub use self::io_usb_hid_receive_status_e as io_usb_hid_receive_status_t;
extern "C" {
    pub static mut G_io_usb_hid_total_length: cty::c_uint;
}
extern "C" {
    pub fn io_usb_hid_init();
}
extern "C" {
    #[doc = " Receive next HID transport packet, returns IO_USB_APDU_RECEIVED when a"]
    #[doc = " complete APDU has been received in the G_io_apdu_buffer To be called"]
    #[doc = " typically upon USB OUT event"]
    pub fn io_usb_hid_receive(
        sndfct: io_send_t,
        buffer: *mut cty::c_uchar,
        l: cty::c_ushort,
    ) -> io_usb_hid_receive_status_t;
}
extern "C" {
    #[doc = " Mark the last chunk transmitted as sent."]
    #[doc = " To be called typically upon USB IN ACK event"]
    pub fn io_usb_hid_sent(sndfct: io_send_t);
}
extern "C" {
    #[doc = " Request transmission of an APDU from the G_io_apdu_buffer using the HID"]
    #[doc = " transport protocol"]
    pub fn io_usb_hid_send(sndfct: io_send_t, sndlength: cty::c_ushort);
}
